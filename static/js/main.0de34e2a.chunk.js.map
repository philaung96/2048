{"version":3,"sources":["Grid.js","Arrows.js","Instruction.js","Game.js","App.js","index.js"],"names":["Grid","props","tilesJsx","tiles","map","tile","index","className","id","score","Arrows","onClick","up","right","down","left","Instruction","Game","useState","board","setBoard","currentScore","didMoved","useEffect","startGame","random","Math","floor","tilesArr","i","updateBoard","every","oneDIndex","row","col","combineTwoTiles","from","to","total","findNumOnLeft","currentRow","exit","moveRight","currentIndex","indexOnLeft","findNumOnRight","moveLeft","indexOnRight","findNumBelow","below","moveUp","indexBelow","findNumAbove","above","moveDown","indexAbove","handleKeyPress","key","$","off","on","e","indexOf","code","console","log","preventDefault","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.0de34e2a.chunk.js","sourcesContent":["const Grid = (props) => {\n\tlet tilesJsx = [];\n\n\tif (props.tiles)\n\t\ttilesJsx = props.tiles.map((tile, index) => (\n\t\t\t<div className='tile' key={index}>\n\t\t\t\t<h2>{tile ? tile : ''}</h2>\n\t\t\t</div>\n\t\t));\n\treturn (\n\t\t<>\n\t\t\t<h3 id='score'>SCORE : {props.score}</h3>\n\t\t\t<div id='grid'>{tilesJsx && tilesJsx}</div>\n\t\t</>\n\t);\n};\n\nexport default Grid;\n","const Arrows = (props) => {\n\treturn (\n\t\t<div id='arrows'>\n\t\t\t<div id='arrow-top' onClick={() => props.up()}>\n\t\t\t\t<i className='far fa-arrow-alt-circle-up fa-3x'></i>\n\t\t\t</div>\n\t\t\t<div id='arrow-right' onClick={() => props.right()}>\n\t\t\t\t<i className='far fa-arrow-alt-circle-right fa-3x'></i>\n\t\t\t</div>\n\t\t\t<div id='arrow-bottom' onClick={() => props.down()}>\n\t\t\t\t<i className='far fa-arrow-alt-circle-down fa-3x'></i>\n\t\t\t</div>\n\t\t\t<div id='arrow-left' onClick={() => props.left()}>\n\t\t\t\t<i className='far fa-arrow-alt-circle-left fa-3x'></i>\n\t\t\t</div>\n\t\t</div>\n\t);\n};\n\nexport default Arrows;\n","const Instruction = () => {\n\treturn (\n\t\t<div id='instruction'>\n\t\t\t<h2>How To Play</h2>\n\t\t\t<p>\n\t\t\t\tUse Arrow Keys To Move The Tiles\n\t\t\t\t<br />\n\t\t\t\tTiles With The Same Number Will Combine Into One\n\t\t\t</p>\n\t\t</div>\n\t);\n};\n\nexport default Instruction;\n","import Grid from './Grid';\nimport Arrows from './Arrows';\nimport Instruction from './Instruction';\nimport { useState, useEffect } from 'react';\nimport $ from 'jquery';\n\nconst Game = () => {\n\tconst [board, setBoard] = useState({\n\t\ttiles: [],\n\t\tscore: 0,\n\t});\n\tconst tiles = [...board.tiles];\n\tlet currentScore = board.score;\n\tlet didMoved = false;\n\n\t// ********** COMPONENT RERENDER FUNCTION **********\n\n\t// start the game on load\n\tuseEffect(() => {\n\t\tstartGame();\n\t}, []);\n\n\t// Initialize the Board\n\tconst startGame = () => {\n\t\t// create a random index from 0-15\n\t\tlet random = Math.floor(Math.random() * 16);\n\t\tconst tilesArr = [];\n\t\t// place 2 at the random index\n\t\t// and 0 at the rest\n\t\tfor (let i = 0; i < 16; i++) {\n\t\t\tif (i === random) tilesArr[i] = 2;\n\t\t\telse tilesArr[i] = 0;\n\t\t}\n\t\t// update the state for component to rerender\n\t\tsetBoard({ tiles: tilesArr, score: 0 });\n\t};\n\n\t// Update the state for component to rerender the\n\t// update tiles\n\tconst updateBoard = () => {\n\t\t// get a random value between 0-15\n\t\tlet random = Math.floor(Math.random() * 16);\n\t\t// keep getting random value till there is an empty spot\n\t\twhile (tiles[random] > 0) {\n\t\t\trandom = Math.floor(Math.random() * 16);\n\t\t}\n\t\t// populate the empty spot\n\t\ttiles[random] = 2;\n\t\t// if every tile is populated, game over\n\t\tif (tiles.every((tile) => tile > 0)) startGame();\n\t\t// else, update the state for component to\n\t\t// rerender\n\t\telse setBoard({ tiles: tiles, score: currentScore });\n\t};\n\n\t// ********** HELPER FUNCTIONS **********\n\n\t// translate rows and cols into one dimensional index\n\tconst oneDIndex = (row, col) => {\n\t\treturn row * 4 + col;\n\t};\n\n\t// Combine two tiles into one by indices\n\t// from -> index of tile combining from -> int\n\t// to -> index of tile combining into -> int\n\tconst combineTwoTiles = (from, to) => {\n\t\tlet total = tiles[to] + tiles[from];\n\t\t// if the tiles combine, update score\n\t\tif (tiles[to] === tiles[from]) currentScore += total;\n\t\t// combine two tiles into 'to' index\n\t\ttiles[to] = total;\n\t\t// empty the tile at 'from' index\n\t\ttiles[from] = 0;\n\t\t// set didMoved to true for component to rerender\n\t\tdidMoved = true;\n\t};\n\n\t// ********** MOVEMENTS **********\n\n\t// ========== MOVING TILES TO RIGHT ==========\n\n\t// Find the index of a tile that isn't zero on left\n\t// of given index\n\t// index -> index of a tile -> int\n\t// return -> index of a tile if found else -1\n\tconst findNumOnLeft = (index) => {\n\t\t// keep track of the current row\n\t\tconst currentRow = Math.floor(index / 4);\n\t\t// one index left of given index\n\t\tlet left = index - 1;\n\t\t// condition to exit the loop\n\t\tlet exit = false;\n\t\twhile (!exit) {\n\t\t\t// if the tile on left is not 0, return that\n\t\t\t// index\n\t\t\tif (tiles[left] > 0) return left;\n\t\t\t// keep going left\n\t\t\tleft--;\n\t\t\t// if there is no more tile on left to go or\n\t\t\t// index is out of current row, exit the loop\n\t\t\tif (left < 0 || Math.floor(left / 4) !== currentRow) exit = true;\n\t\t}\n\t\treturn -1;\n\t};\n\n\t// Move the individual tiles to right if possible\n\t// go through each row, then every columns of that\n\t// row, then move none 0 tiles to right if there is\n\t// a space\n\tconst moveRight = () => {\n\t\t// iterate through each rows\n\t\tfor (let row = 0; row < 4; row++) {\n\t\t\t// iterate through columns from right to left\n\t\t\t// excluding the first column\n\t\t\tfor (let col = 3; col >= 1; col--) {\n\t\t\t\t// one dimensional index of the tile\n\t\t\t\tlet currentIndex = oneDIndex(row, col);\n\t\t\t\t// find a non empty tile on left of\n\t\t\t\t// current\n\t\t\t\tlet indexOnLeft = findNumOnLeft(currentIndex);\n\t\t\t\t// found\n\t\t\t\tif (indexOnLeft !== -1) {\n\t\t\t\t\t// check if current tile is zero\n\t\t\t\t\t// if zero, move tile found on left\n\t\t\t\t\t// into current\n\t\t\t\t\tif (tiles[currentIndex] === 0) {\n\t\t\t\t\t\tcombineTwoTiles(indexOnLeft, currentIndex);\n\t\t\t\t\t\t// stay at current place and\n\t\t\t\t\t\t// check one more time\n\t\t\t\t\t\tcol++;\n\t\t\t\t\t}\n\t\t\t\t\t// is not zero\n\t\t\t\t\telse {\n\t\t\t\t\t\t// if tile found on left is same\n\t\t\t\t\t\t// as current, combine tile on\n\t\t\t\t\t\t// left into current\n\t\t\t\t\t\tif (tiles[currentIndex] === tiles[indexOnLeft])\n\t\t\t\t\t\t\tcombineTwoTiles(indexOnLeft, currentIndex);\n\t\t\t\t\t\t// if tile found on left and\n\t\t\t\t\t\t// current are not same, and\n\t\t\t\t\t\t// tile on left is not one\n\t\t\t\t\t\t// position left of current,\n\t\t\t\t\t\t// move tile on left into one\n\t\t\t\t\t\t// tile left of current\n\t\t\t\t\t\telse if (currentIndex - 1 !== indexOnLeft)\n\t\t\t\t\t\t\tcombineTwoTiles(indexOnLeft, currentIndex - 1);\n\t\t\t\t\t\t// else do nothing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if not found do nothing\n\t\t\t}\n\t\t}\n\t\t// update the state to rerender the component\n\t\t// if the tile(s) moved\n\t\tif (didMoved) updateBoard();\n\t};\n\n\t// ========== MOVING TILES TO LEFT ==========\n\n\t// Find the index of a tile that isn't zero on right\n\t// of given index\n\t// index -> index of a tile -> int\n\t// return -> index of a tile if found else -1\n\tconst findNumOnRight = (index) => {\n\t\t// keep track of the current row\n\t\tconst currentRow = Math.floor(index / 4);\n\t\t// one index right of given index\n\t\tlet right = index + 1;\n\t\t// condition to exit the loop\n\t\tlet exit = false;\n\t\twhile (!exit) {\n\t\t\t// if the tile on right is not 0, return\n\t\t\t// that index\n\t\t\tif (tiles[right] > 0) return right;\n\t\t\t// keep going right\n\t\t\tright++;\n\t\t\t// if there is no more tile on left to go or\n\t\t\t// index is out of current row, exit the loop\n\t\t\tif (right > 15 || Math.floor(right / 4) !== currentRow) exit = true;\n\t\t}\n\t\treturn -1;\n\t};\n\n\t// Move the individual tiles to left if possible\n\t// go through each row, then every columns of that\n\t// row, then move none 0 tiles to left if there is\n\t// a space\n\tconst moveLeft = () => {\n\t\t// iterate through each rows\n\t\tfor (let row = 0; row < 4; row++) {\n\t\t\t// iterate through columns from left to right\n\t\t\t// excluding the last column\n\t\t\tfor (let col = 0; col < 3; col++) {\n\t\t\t\t// one dimensional index of the tile\n\t\t\t\tlet currentIndex = oneDIndex(row, col);\n\t\t\t\t// find a non empty tile on right of\n\t\t\t\t// current\n\t\t\t\tlet indexOnRight = findNumOnRight(currentIndex);\n\t\t\t\t// found\n\t\t\t\tif (indexOnRight !== -1) {\n\t\t\t\t\t// check if current tile is zero\n\t\t\t\t\t// if zero, move tile found on right\n\t\t\t\t\t// into current\n\t\t\t\t\tif (tiles[currentIndex] === 0) {\n\t\t\t\t\t\tcombineTwoTiles(indexOnRight, currentIndex);\n\t\t\t\t\t\t// stay at current place and\n\t\t\t\t\t\t// check one more time\n\t\t\t\t\t\tcol--;\n\t\t\t\t\t}\n\t\t\t\t\t// is not zero\n\t\t\t\t\telse {\n\t\t\t\t\t\t// if tile found on right is same\n\t\t\t\t\t\t// as current, combine tile on\n\t\t\t\t\t\t// right into current\n\t\t\t\t\t\tif (tiles[currentIndex] === tiles[indexOnRight])\n\t\t\t\t\t\t\tcombineTwoTiles(indexOnRight, currentIndex);\n\t\t\t\t\t\t// if tile found on right and\n\t\t\t\t\t\t// current are not same, and\n\t\t\t\t\t\t// tile on right is not one\n\t\t\t\t\t\t// position right of current,\n\t\t\t\t\t\t// move tile on right into one\n\t\t\t\t\t\t// tile right of current\n\t\t\t\t\t\telse if (currentIndex + 1 !== indexOnRight)\n\t\t\t\t\t\t\tcombineTwoTiles(indexOnRight, currentIndex + 1);\n\t\t\t\t\t\t// else do nothing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if not found do nothing\n\t\t\t}\n\t\t}\n\t\t// update the state to rerender the component\n\t\t// if the tile(s) moved\n\t\tif (didMoved) updateBoard();\n\t};\n\n\t// ========== MOVING TILES UP ==========\n\n\t// Find the index of a tile that isn't zero on bottom\n\t// of given index\n\t// index -> index of a tile -> int\n\t// return -> index of a tile if found else -1\n\tconst findNumBelow = (index) => {\n\t\t// tile that is one below the index\n\t\tlet below = index + 4;\n\t\t// condition to exit the loop\n\t\tlet exit = false;\n\t\twhile (!exit) {\n\t\t\t// if the tile below is not 0, return that\n\t\t\t// index\n\t\t\tif (tiles[below] > 0) return below;\n\t\t\t// keep going below\n\t\t\tbelow += 4;\n\t\t\t// if there is no more tiles below,\n\t\t\t// exit the loop\n\t\t\tif (below > 15) exit = true;\n\t\t}\n\t\treturn -1;\n\t};\n\n\t// Move the individual tiles to up if possible\n\t// go through each col, then every rows that\n\t// contains that col , then move none 0 tiles up\n\t// if there is a space\n\tconst moveUp = () => {\n\t\t// iterate through each columns left to right\n\t\tfor (let col = 0; col < 4; col++) {\n\t\t\t// iterate through rows from top to bottom\n\t\t\t// excluding the last row\n\t\t\tfor (let row = 0; row < 3; row++) {\n\t\t\t\t// one dimensional index of the tile\n\t\t\t\tlet currentIndex = oneDIndex(row, col);\n\t\t\t\t// find a non empty tile below of current\n\t\t\t\tlet indexBelow = findNumBelow(currentIndex);\n\t\t\t\t// found\n\t\t\t\tif (indexBelow !== -1) {\n\t\t\t\t\t// check if current tile is zero\n\t\t\t\t\t// if zero, move tile found below\n\t\t\t\t\t// into current\n\t\t\t\t\tif (tiles[currentIndex] === 0) {\n\t\t\t\t\t\tcombineTwoTiles(indexBelow, currentIndex);\n\t\t\t\t\t\t// stay at current place and\n\t\t\t\t\t\t// check one more time\n\t\t\t\t\t\trow--;\n\t\t\t\t\t}\n\t\t\t\t\t// is not zero\n\t\t\t\t\telse {\n\t\t\t\t\t\t// if tile found below is same as\n\t\t\t\t\t\t// current, combine tile below\n\t\t\t\t\t\t// into current\n\t\t\t\t\t\tif (tiles[currentIndex] === tiles[indexBelow])\n\t\t\t\t\t\t\tcombineTwoTiles(indexBelow, currentIndex);\n\t\t\t\t\t\t// if tile found below and\n\t\t\t\t\t\t// current are not same, and\n\t\t\t\t\t\t// tile below is not one row\n\t\t\t\t\t\t// below of current, move below\n\t\t\t\t\t\t// into one tile below current\n\t\t\t\t\t\telse if (currentIndex + 4 !== indexBelow)\n\t\t\t\t\t\t\tcombineTwoTiles(indexBelow, currentIndex + 4);\n\t\t\t\t\t\t// else do nothing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if not found do nothing\n\t\t\t}\n\t\t}\n\t\t// update the state to rerender the component\n\t\t// if the tile(s) moved\n\t\tif (didMoved) updateBoard();\n\t};\n\n\t// ========== MOVING TILES DOWN ==========\n\n\t// Find the index of a tile that isn't zero on above\n\t// of given index\n\t// index -> index of a tile -> int\n\t// return -> index of a tile if found else -1\n\tconst findNumAbove = (index) => {\n\t\t// tile that is one above the index\n\t\tlet above = index - 4;\n\t\t// condition to exit the loop\n\t\tlet exit = false;\n\t\twhile (!exit) {\n\t\t\t// if the tile above is not 0, return that\n\t\t\t// index\n\t\t\tif (tiles[above] > 0) return above;\n\t\t\t// keep going above\n\t\t\tabove -= 4;\n\t\t\t// if there is no more tiles above,\n\t\t\t// exit the loop\n\t\t\tif (above < 0) exit = true;\n\t\t}\n\t\treturn -1;\n\t};\n\n\t// Move the individual tiles down if possible\n\t// go through each col, then every rows that\n\t// contains that col , then move none 0 tiles down\n\t// if there is a space\n\tconst moveDown = () => {\n\t\t// iterate through each columns left to right\n\t\tfor (let col = 0; col < 4; col++) {\n\t\t\t// iterate through rows from top to bottom\n\t\t\t// excluding the first row\n\t\t\tfor (let row = 3; row > 0; row--) {\n\t\t\t\t// one dimensional index of the tile\n\t\t\t\tlet currentIndex = oneDIndex(row, col);\n\t\t\t\t// find a non empty tile above of current\n\t\t\t\tlet indexAbove = findNumAbove(currentIndex);\n\t\t\t\t// found\n\t\t\t\tif (indexAbove !== -1) {\n\t\t\t\t\t// check if current tile is zero\n\t\t\t\t\t// if zero, move tile found above\n\t\t\t\t\t// into current\n\t\t\t\t\tif (tiles[currentIndex] === 0) {\n\t\t\t\t\t\tcombineTwoTiles(indexAbove, currentIndex);\n\t\t\t\t\t\t// stay at current place and\n\t\t\t\t\t\t// check one more time\n\t\t\t\t\t\trow++;\n\t\t\t\t\t}\n\t\t\t\t\t// is not zero\n\t\t\t\t\telse {\n\t\t\t\t\t\t// if tile found above is same as\n\t\t\t\t\t\t// current, combine tile above\n\t\t\t\t\t\t// into current\n\t\t\t\t\t\tif (tiles[currentIndex] === tiles[indexAbove])\n\t\t\t\t\t\t\tcombineTwoTiles(indexAbove, currentIndex);\n\t\t\t\t\t\t// if tile found above and\n\t\t\t\t\t\t// current are not same, and\n\t\t\t\t\t\t// tile above is not one row\n\t\t\t\t\t\t// above of current, move above\n\t\t\t\t\t\t// into one tile above current\n\t\t\t\t\t\telse if (currentIndex - 4 !== indexAbove)\n\t\t\t\t\t\t\tcombineTwoTiles(indexAbove, currentIndex - 4);\n\t\t\t\t\t\t// else do nothing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if not found do nothing\n\t\t\t}\n\t\t}\n\t\t// update the state to rerender the component\n\t\t// if the tile(s) moved\n\t\tif (didMoved) updateBoard();\n\t};\n\n\t// ********** HANDLE KEY PRESS **********\n\n\t// Take action accordingly after user pressed a key\n\t// key -> key pressed by user -> string\n\tconst handleKeyPress = (key) => {\n\t\tswitch (key) {\n\t\t\t// left arrow key pressed\n\t\t\t// move the tiles to left if possible\n\t\t\tcase 'ArrowLeft':\n\t\t\t\tmoveLeft();\n\t\t\t\tbreak;\n\t\t\t// up arrow key pressed\n\t\t\t// move the tiles up if possible\n\t\t\tcase 'ArrowUp':\n\t\t\t\tmoveUp();\n\t\t\t\tbreak;\n\t\t\t// right arrow key pressed\n\t\t\t// move the tiles to right if possible\n\t\t\tcase 'ArrowRight':\n\t\t\t\tmoveRight();\n\t\t\t\tbreak;\n\t\t\t// down arrow key pressed\n\t\t\t// move the tiles down if possible\n\t\t\tcase 'ArrowDown':\n\t\t\t\tmoveDown();\n\t\t\t\tbreak;\n\t\t\t// Do nothing for the rest of the key\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\t// on key press, call the handleKeyPress function\n\t// with the key value as parameter\n\t$('body').off('keyup');\n\t$('body').on('keyup', (e) => {\n\t\t// prevent scrolling\n\t\tif (['Space', 'ArrowUp', 'ArrowDown'].indexOf(e.code) > -1) {\n\t\t\tconsole.log(e);\n\t\t\te.preventDefault();\n\t\t}\n\t\thandleKeyPress(e.key);\n\t});\n\n\t// ========== END OF FUNCTIONALITY ==========\n\n\treturn (\n\t\t<div id='game'>\n\t\t\t<h1>2048</h1>\n\t\t\t<Grid\n\t\t\t\ttiles={board.tiles}\n\t\t\t\tscore={board.score}\n\t\t\t\thandleKeyPress={handleKeyPress}\n\t\t\t/>\n\t\t\t<Arrows up={moveUp} right={moveRight} down={moveDown} left={moveLeft} />\n\t\t\t<Instruction />\n\t\t</div>\n\t);\n};\n\nexport default Game;\n","import './App.css';\nimport Game from './Game';\n\nfunction App() {\n\treturn (\n\t\t<div id='App'>\n\t\t\t<Game />\n\t\t</div>\n\t);\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}