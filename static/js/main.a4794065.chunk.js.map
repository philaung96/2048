{"version":3,"sources":["Grid.js","Arrows.js","Instruction.js","Game.js","App.js","index.js"],"names":["Grid","props","tilesJsx","tiles","map","tile","index","className","id","best","score","Arrows","onClick","up","right","down","left","Instruction","href","target","rel","Game","useState","board","setBoard","currentScore","didMoved","useEffect","localStorage","data","localData","JSON","parse","getItem","localTiles","localBest","localScore","startGame","random","Math","floor","tilesArr","i","updateBoard","maxScore","setItem","stringify","every","isMovable","bottomMovable","rightMovable","movable","console","log","oneDIndex","row","col","combineTwoTiles","from","to","total","findNumOnLeft","currentRow","exit","moveRight","currentIndex","indexOnLeft","findNumOnRight","moveLeft","indexOnRight","findNumBelow","below","moveUp","indexBelow","findNumAbove","above","moveDown","indexAbove","handleKeyPress","key","$","off","on","e","indexOf","code","preventDefault","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.a4794065.chunk.js","sourcesContent":["const Grid = (props) => {\n\tlet tilesJsx = [];\n\n\tif (props.tiles)\n\t\ttilesJsx = props.tiles.map((tile, index) => (\n\t\t\t<div className='tile' key={index}>\n\t\t\t\t<h2>{tile ? tile : ''}</h2>\n\t\t\t</div>\n\t\t));\n\treturn (\n\t\t<>\n\t\t\t<h3 id='best'>BEST : {props.best}</h3>\n\t\t\t<h3 id='score'>SCORE : {props.score}</h3>\n\t\t\t<div id='grid'>{tilesJsx && tilesJsx}</div>\n\t\t</>\n\t);\n};\n\nexport default Grid;\n","const Arrows = (props) => {\n\treturn (\n\t\t<div id='arrows'>\n\t\t\t<div id='arrow-top' onClick={() => props.up()}>\n\t\t\t\t<i className='far fa-arrow-alt-circle-up fa-3x'></i>\n\t\t\t</div>\n\t\t\t<div id='arrow-right' onClick={() => props.right()}>\n\t\t\t\t<i className='far fa-arrow-alt-circle-right fa-3x'></i>\n\t\t\t</div>\n\t\t\t<div id='arrow-bottom' onClick={() => props.down()}>\n\t\t\t\t<i className='far fa-arrow-alt-circle-down fa-3x'></i>\n\t\t\t</div>\n\t\t\t<div id='arrow-left' onClick={() => props.left()}>\n\t\t\t\t<i className='far fa-arrow-alt-circle-left fa-3x'></i>\n\t\t\t</div>\n\t\t</div>\n\t);\n};\n\nexport default Arrows;\n","const Instruction = () => {\n\treturn (\n\t\t<div id='instruction'>\n\t\t\t<h2>How To Play</h2>\n\t\t\t<p>\n\t\t\t\tUse <i>Arrow Keys</i>, Or <i>Arrow Buttons</i> To Move The Tiles\n\t\t\t\t<br />\n\t\t\t\tTiles With The Same Number Will Combine Into One\n\t\t\t\t<br />\n\t\t\t\t<br />\n\t\t\t\tCheck Out The Git Hub Repo.\n\t\t\t\t<br />\n\t\t\t\t<br />\n\t\t\t\t<a\n\t\t\t\t\thref='https://github.com/philaung96/2048'\n\t\t\t\t\ttarget='_blank'\n\t\t\t\t\trel='noreferrer'>\n\t\t\t\t\t<i>HERE</i>\n\t\t\t\t</a>\n\t\t\t</p>\n\t\t</div>\n\t);\n};\n\nexport default Instruction;\n","import Grid from './Grid';\nimport Arrows from './Arrows';\nimport Instruction from './Instruction';\nimport { useState, useEffect } from 'react';\nimport $ from 'jquery';\n\nconst Game = () => {\n\tconst [board, setBoard] = useState(null);\n\n\tlet tiles = [];\n\tlet currentScore = 0;\n\tlet didMoved = false;\n\n\tif (board) {\n\t\ttiles = [...board.tiles];\n\t\tcurrentScore = board.score;\n\t}\n\n\t// ********** COMPONENT RERENDER FUNCTIONS **********\n\n\t// on initial load\n\tuseEffect(() => {\n\t\t// if there is data in local storage grab that data and update state\n\t\tif (localStorage.data) {\n\t\t\tconst localData = JSON.parse(localStorage.getItem('data'));\n\t\t\tsetBoard({\n\t\t\t\ttiles: [...localData.localTiles],\n\t\t\t\tbest: localData.localBest,\n\t\t\t\tscore: localData.localScore,\n\t\t\t});\n\t\t}\n\t\t// else keep current state data\n\t\telse startGame();\n\t}, []);\n\n\t// Initialize the Board\n\tconst startGame = () => {\n\t\t// create a random index from 0-15\n\t\tlet random = Math.floor(Math.random() * 16);\n\t\tconst tilesArr = [];\n\t\t// place 2 at the random index\n\t\t// and 0 at the rest\n\t\tfor (let i = 0; i < 16; i++) {\n\t\t\tif (i === random) tilesArr[i] = 2;\n\t\t\telse tilesArr[i] = 0;\n\t\t}\n\t\t// update the state for component to rerender\n\t\tsetBoard({ tiles: tilesArr, best: 0, score: 0 });\n\t};\n\n\t// Check if any tile is movable to bottom or right\n\t// only bottom or right since the iteration is done\n\t// top to bottom, left to right\n\t// Should only be called when all tiles are populated\n\t// return -> boolean\n\tconst movable = () => {\n\t\tlet isMovable = false;\n\n\t\t// checks if the tile below is same as tile at\n\t\t// index\n\t\t// index -> index of a tile -> int\n\t\t// return -> true if two tiles are same else\n\t\t// false\n\t\tconst bottomMovable = (index) => {\n\t\t\t// if the bottom tile exist and the bottom\n\t\t\t// tile has same value as tile at index,\n\t\t\t// return true. If not, return false\n\t\t\tif (index + 4 < 15 && tiles[index] === tiles[index + 4]) return true;\n\t\t\telse return false;\n\t\t};\n\n\t\t// checks if the tile on right is same as tile at\n\t\t// index\n\t\t// index -> index of a tile -> int\n\t\t// return -> true if two tiles are same else\n\t\t// false\n\t\tconst rightMovable = (index) => {\n\t\t\tconst initialRow = index / 4;\n\t\t\t// if the tile at right is not on same row as\n\t\t\t// current tile or current tile and tile on\n\t\t\t// right are not the same, return false. If\n\t\t\t// not, return true\n\t\t\tif ((index + 1) / 4 !== initialRow || tiles[index] !== tiles[index + 1])\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t};\n\n\t\t// no need to check last index since the one\n\t\t// before last will check if they are the same\n\t\tfor (let index = 0; index < 15; index++) {\n\t\t\t// if any tile on bottom or right is same as\n\t\t\t// current tile set return value true and\n\t\t\t// quite iterating over tiles\n\t\t\tif (bottomMovable(index) || rightMovable(index)) {\n\t\t\t\tisMovable = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// return false by default\n\t\treturn isMovable;\n\t};\n\n\tconst gameOver = () => {\n\t\tconsole.log('game over');\n\t\tstartGame();\n\t};\n\n\t// Update the state for component to rerender the\n\t// update tiles\n\tconst updateBoard = () => {\n\t\t// get a random value between 0-15\n\t\tlet random = Math.floor(Math.random() * 16);\n\n\t\t// keep getting random value till there is an empty spot\n\t\twhile (tiles[random] > 0) {\n\t\t\trandom = Math.floor(Math.random() * 16);\n\t\t}\n\n\t\t// populate the empty spot\n\t\ttiles[random] = 2;\n\n\t\t// ========== LOCAL STORAGE ==========\n\t\tconst localData = JSON.parse(localStorage.getItem('data'));\n\n\t\t// if current score is higher than one in local\n\t\t// save current as best else keep local best\n\t\tlet maxScore = 0;\n\t\tcurrentScore > localData.localBest\n\t\t\t? (maxScore = currentScore)\n\t\t\t: (maxScore = localData.localBest);\n\n\t\t// store data to localStorage before changing\n\t\t// state\n\t\tlocalStorage.setItem(\n\t\t\t'data',\n\t\t\tJSON.stringify({\n\t\t\t\tlocalTiles: [...tiles],\n\t\t\t\tlocalBest: maxScore,\n\t\t\t\tlocalScore: currentScore,\n\t\t\t})\n\t\t);\n\t\t// ========== LOCAL STORAGE ==========\n\n\t\t// if every tile is populated, and no\n\t\t// possibility to move any way, game over\n\t\tif (tiles.every((tile) => tile > 0) && !movable()) gameOver();\n\t\t// else, update the state for component to\n\t\t// rerender\n\t\telse setBoard({ tiles: tiles, best: maxScore, score: currentScore });\n\t};\n\n\t// ********** HELPER FUNCTIONS **********\n\n\t// translate rows and cols into one dimensional index\n\tconst oneDIndex = (row, col) => {\n\t\treturn row * 4 + col;\n\t};\n\n\t// Combine two tiles into one by indices\n\t// from -> index of tile combining from -> int\n\t// to -> index of tile combining into -> int\n\tconst combineTwoTiles = (from, to) => {\n\t\tlet total = tiles[to] + tiles[from];\n\t\t// if the tiles combine, update score\n\t\tif (tiles[to] === tiles[from]) currentScore += total;\n\t\t// combine two tiles into 'to' index\n\t\ttiles[to] = total;\n\t\t// empty the tile at 'from' index\n\t\ttiles[from] = 0;\n\t\t// set didMoved to true for component to rerender\n\t\tdidMoved = true;\n\t};\n\n\t// ********** MOVEMENTS **********\n\n\t// ========== MOVING TILES TO RIGHT ==========\n\n\t// Find the index of a tile that isn't zero on left\n\t// of given index\n\t// index -> index of a tile -> int\n\t// return -> index of a tile if found else -1\n\tconst findNumOnLeft = (index) => {\n\t\t// keep track of the current row\n\t\tconst currentRow = Math.floor(index / 4);\n\t\t// one index left of given index\n\t\tlet left = index - 1;\n\t\t// condition to exit the loop\n\t\tlet exit = false;\n\t\twhile (!exit) {\n\t\t\t// if the tile on left is not 0, return that\n\t\t\t// index\n\t\t\tif (tiles[left] > 0) return left;\n\t\t\t// keep going left\n\t\t\tleft--;\n\t\t\t// if there is no more tile on left to go or\n\t\t\t// index is out of current row, exit the loop\n\t\t\tif (left < 0 || Math.floor(left / 4) !== currentRow) exit = true;\n\t\t}\n\t\treturn -1;\n\t};\n\n\t// Move the individual tiles to right if possible\n\t// go through each row, then every columns of that\n\t// row, then move none 0 tiles to right if there is\n\t// a space\n\tconst moveRight = () => {\n\t\t// iterate through each rows\n\t\tfor (let row = 0; row < 4; row++) {\n\t\t\t// iterate through columns from right to left\n\t\t\t// excluding the first column\n\t\t\tfor (let col = 3; col >= 1; col--) {\n\t\t\t\t// one dimensional index of the tile\n\t\t\t\tlet currentIndex = oneDIndex(row, col);\n\t\t\t\t// find a non empty tile on left of\n\t\t\t\t// current\n\t\t\t\tlet indexOnLeft = findNumOnLeft(currentIndex);\n\t\t\t\t// found\n\t\t\t\tif (indexOnLeft !== -1) {\n\t\t\t\t\t// check if current tile is zero\n\t\t\t\t\t// if zero, move tile found on left\n\t\t\t\t\t// into current\n\t\t\t\t\tif (tiles[currentIndex] === 0) {\n\t\t\t\t\t\tcombineTwoTiles(indexOnLeft, currentIndex);\n\t\t\t\t\t\t// stay at current place and\n\t\t\t\t\t\t// check one more time\n\t\t\t\t\t\tcol++;\n\t\t\t\t\t}\n\t\t\t\t\t// is not zero\n\t\t\t\t\telse {\n\t\t\t\t\t\t// if tile found on left is same\n\t\t\t\t\t\t// as current, combine tile on\n\t\t\t\t\t\t// left into current\n\t\t\t\t\t\tif (tiles[currentIndex] === tiles[indexOnLeft])\n\t\t\t\t\t\t\tcombineTwoTiles(indexOnLeft, currentIndex);\n\t\t\t\t\t\t// if tile found on left and\n\t\t\t\t\t\t// current are not same, and\n\t\t\t\t\t\t// tile on left is not one\n\t\t\t\t\t\t// position left of current,\n\t\t\t\t\t\t// move tile on left into one\n\t\t\t\t\t\t// tile left of current\n\t\t\t\t\t\telse if (currentIndex - 1 !== indexOnLeft)\n\t\t\t\t\t\t\tcombineTwoTiles(indexOnLeft, currentIndex - 1);\n\t\t\t\t\t\t// else do nothing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if not found do nothing\n\t\t\t}\n\t\t}\n\t\t// update the state to rerender the component\n\t\t// if the tile(s) moved\n\t\tif (didMoved) updateBoard();\n\t};\n\n\t// ========== MOVING TILES TO LEFT ==========\n\n\t// Find the index of a tile that isn't zero on right\n\t// of given index\n\t// index -> index of a tile -> int\n\t// return -> index of a tile if found else -1\n\tconst findNumOnRight = (index) => {\n\t\t// keep track of the current row\n\t\tconst currentRow = Math.floor(index / 4);\n\t\t// one index right of given index\n\t\tlet right = index + 1;\n\t\t// condition to exit the loop\n\t\tlet exit = false;\n\t\twhile (!exit) {\n\t\t\t// if the tile on right is not 0, return\n\t\t\t// that index\n\t\t\tif (tiles[right] > 0) return right;\n\t\t\t// keep going right\n\t\t\tright++;\n\t\t\t// if there is no more tile on left to go or\n\t\t\t// index is out of current row, exit the loop\n\t\t\tif (right > 15 || Math.floor(right / 4) !== currentRow) exit = true;\n\t\t}\n\t\treturn -1;\n\t};\n\n\t// Move the individual tiles to left if possible\n\t// go through each row, then every columns of that\n\t// row, then move none 0 tiles to left if there is\n\t// a space\n\tconst moveLeft = () => {\n\t\t// iterate through each rows\n\t\tfor (let row = 0; row < 4; row++) {\n\t\t\t// iterate through columns from left to right\n\t\t\t// excluding the last column\n\t\t\tfor (let col = 0; col < 3; col++) {\n\t\t\t\t// one dimensional index of the tile\n\t\t\t\tlet currentIndex = oneDIndex(row, col);\n\t\t\t\t// find a non empty tile on right of\n\t\t\t\t// current\n\t\t\t\tlet indexOnRight = findNumOnRight(currentIndex);\n\t\t\t\t// found\n\t\t\t\tif (indexOnRight !== -1) {\n\t\t\t\t\t// check if current tile is zero\n\t\t\t\t\t// if zero, move tile found on right\n\t\t\t\t\t// into current\n\t\t\t\t\tif (tiles[currentIndex] === 0) {\n\t\t\t\t\t\tcombineTwoTiles(indexOnRight, currentIndex);\n\t\t\t\t\t\t// stay at current place and\n\t\t\t\t\t\t// check one more time\n\t\t\t\t\t\tcol--;\n\t\t\t\t\t}\n\t\t\t\t\t// is not zero\n\t\t\t\t\telse {\n\t\t\t\t\t\t// if tile found on right is same\n\t\t\t\t\t\t// as current, combine tile on\n\t\t\t\t\t\t// right into current\n\t\t\t\t\t\tif (tiles[currentIndex] === tiles[indexOnRight])\n\t\t\t\t\t\t\tcombineTwoTiles(indexOnRight, currentIndex);\n\t\t\t\t\t\t// if tile found on right and\n\t\t\t\t\t\t// current are not same, and\n\t\t\t\t\t\t// tile on right is not one\n\t\t\t\t\t\t// position right of current,\n\t\t\t\t\t\t// move tile on right into one\n\t\t\t\t\t\t// tile right of current\n\t\t\t\t\t\telse if (currentIndex + 1 !== indexOnRight)\n\t\t\t\t\t\t\tcombineTwoTiles(indexOnRight, currentIndex + 1);\n\t\t\t\t\t\t// else do nothing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if not found do nothing\n\t\t\t}\n\t\t}\n\t\t// update the state to rerender the component\n\t\t// if the tile(s) moved\n\t\tif (didMoved) updateBoard();\n\t};\n\n\t// ========== MOVING TILES UP ==========\n\n\t// Find the index of a tile that isn't zero on bottom\n\t// of given index\n\t// index -> index of a tile -> int\n\t// return -> index of a tile if found else -1\n\tconst findNumBelow = (index) => {\n\t\t// tile that is one below the index\n\t\tlet below = index + 4;\n\t\t// condition to exit the loop\n\t\tlet exit = false;\n\t\twhile (!exit) {\n\t\t\t// if the tile below is not 0, return that\n\t\t\t// index\n\t\t\tif (tiles[below] > 0) return below;\n\t\t\t// keep going below\n\t\t\tbelow += 4;\n\t\t\t// if there is no more tiles below,\n\t\t\t// exit the loop\n\t\t\tif (below > 15) exit = true;\n\t\t}\n\t\treturn -1;\n\t};\n\n\t// Move the individual tiles to up if possible\n\t// go through each col, then every rows that\n\t// contains that col , then move none 0 tiles up\n\t// if there is a space\n\tconst moveUp = () => {\n\t\t// iterate through each columns left to right\n\t\tfor (let col = 0; col < 4; col++) {\n\t\t\t// iterate through rows from top to bottom\n\t\t\t// excluding the last row\n\t\t\tfor (let row = 0; row < 3; row++) {\n\t\t\t\t// one dimensional index of the tile\n\t\t\t\tlet currentIndex = oneDIndex(row, col);\n\t\t\t\t// find a non empty tile below of current\n\t\t\t\tlet indexBelow = findNumBelow(currentIndex);\n\t\t\t\t// found\n\t\t\t\tif (indexBelow !== -1) {\n\t\t\t\t\t// check if current tile is zero\n\t\t\t\t\t// if zero, move tile found below\n\t\t\t\t\t// into current\n\t\t\t\t\tif (tiles[currentIndex] === 0) {\n\t\t\t\t\t\tcombineTwoTiles(indexBelow, currentIndex);\n\t\t\t\t\t\t// stay at current place and\n\t\t\t\t\t\t// check one more time\n\t\t\t\t\t\trow--;\n\t\t\t\t\t}\n\t\t\t\t\t// is not zero\n\t\t\t\t\telse {\n\t\t\t\t\t\t// if tile found below is same as\n\t\t\t\t\t\t// current, combine tile below\n\t\t\t\t\t\t// into current\n\t\t\t\t\t\tif (tiles[currentIndex] === tiles[indexBelow])\n\t\t\t\t\t\t\tcombineTwoTiles(indexBelow, currentIndex);\n\t\t\t\t\t\t// if tile found below and\n\t\t\t\t\t\t// current are not same, and\n\t\t\t\t\t\t// tile below is not one row\n\t\t\t\t\t\t// below of current, move below\n\t\t\t\t\t\t// into one tile below current\n\t\t\t\t\t\telse if (currentIndex + 4 !== indexBelow)\n\t\t\t\t\t\t\tcombineTwoTiles(indexBelow, currentIndex + 4);\n\t\t\t\t\t\t// else do nothing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if not found do nothing\n\t\t\t}\n\t\t}\n\t\t// update the state to rerender the component\n\t\t// if the tile(s) moved\n\t\tif (didMoved) updateBoard();\n\t};\n\n\t// ========== MOVING TILES DOWN ==========\n\n\t// Find the index of a tile that isn't zero on above\n\t// of given index\n\t// index -> index of a tile -> int\n\t// return -> index of a tile if found else -1\n\tconst findNumAbove = (index) => {\n\t\t// tile that is one above the index\n\t\tlet above = index - 4;\n\t\t// condition to exit the loop\n\t\tlet exit = false;\n\t\twhile (!exit) {\n\t\t\t// if the tile above is not 0, return that\n\t\t\t// index\n\t\t\tif (tiles[above] > 0) return above;\n\t\t\t// keep going above\n\t\t\tabove -= 4;\n\t\t\t// if there is no more tiles above,\n\t\t\t// exit the loop\n\t\t\tif (above < 0) exit = true;\n\t\t}\n\t\treturn -1;\n\t};\n\n\t// Move the individual tiles down if possible\n\t// go through each col, then every rows that\n\t// contains that col , then move none 0 tiles down\n\t// if there is a space\n\tconst moveDown = () => {\n\t\t// iterate through each columns left to right\n\t\tfor (let col = 0; col < 4; col++) {\n\t\t\t// iterate through rows from top to bottom\n\t\t\t// excluding the first row\n\t\t\tfor (let row = 3; row > 0; row--) {\n\t\t\t\t// one dimensional index of the tile\n\t\t\t\tlet currentIndex = oneDIndex(row, col);\n\t\t\t\t// find a non empty tile above of current\n\t\t\t\tlet indexAbove = findNumAbove(currentIndex);\n\t\t\t\t// found\n\t\t\t\tif (indexAbove !== -1) {\n\t\t\t\t\t// check if current tile is zero\n\t\t\t\t\t// if zero, move tile found above\n\t\t\t\t\t// into current\n\t\t\t\t\tif (tiles[currentIndex] === 0) {\n\t\t\t\t\t\tcombineTwoTiles(indexAbove, currentIndex);\n\t\t\t\t\t\t// stay at current place and\n\t\t\t\t\t\t// check one more time\n\t\t\t\t\t\trow++;\n\t\t\t\t\t}\n\t\t\t\t\t// is not zero\n\t\t\t\t\telse {\n\t\t\t\t\t\t// if tile found above is same as\n\t\t\t\t\t\t// current, combine tile above\n\t\t\t\t\t\t// into current\n\t\t\t\t\t\tif (tiles[currentIndex] === tiles[indexAbove])\n\t\t\t\t\t\t\tcombineTwoTiles(indexAbove, currentIndex);\n\t\t\t\t\t\t// if tile found above and\n\t\t\t\t\t\t// current are not same, and\n\t\t\t\t\t\t// tile above is not one row\n\t\t\t\t\t\t// above of current, move above\n\t\t\t\t\t\t// into one tile above current\n\t\t\t\t\t\telse if (currentIndex - 4 !== indexAbove)\n\t\t\t\t\t\t\tcombineTwoTiles(indexAbove, currentIndex - 4);\n\t\t\t\t\t\t// else do nothing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if not found do nothing\n\t\t\t}\n\t\t}\n\t\t// update the state to rerender the component\n\t\t// if the tile(s) moved\n\t\tif (didMoved) updateBoard();\n\t};\n\n\t// ********** HANDLE KEY PRESS **********\n\n\t// Take action accordingly after user pressed a key\n\t// key -> key pressed by user -> string\n\tconst handleKeyPress = (key) => {\n\t\tswitch (key) {\n\t\t\t// left arrow key pressed\n\t\t\t// move the tiles to left if possible\n\t\t\tcase 'ArrowLeft':\n\t\t\t\tmoveLeft();\n\t\t\t\tbreak;\n\t\t\t// up arrow key pressed\n\t\t\t// move the tiles up if possible\n\t\t\tcase 'ArrowUp':\n\t\t\t\tmoveUp();\n\t\t\t\tbreak;\n\t\t\t// right arrow key pressed\n\t\t\t// move the tiles to right if possible\n\t\t\tcase 'ArrowRight':\n\t\t\t\tmoveRight();\n\t\t\t\tbreak;\n\t\t\t// down arrow key pressed\n\t\t\t// move the tiles down if possible\n\t\t\tcase 'ArrowDown':\n\t\t\t\tmoveDown();\n\t\t\t\tbreak;\n\t\t\t// Do nothing for the rest of the key\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\t// on key press, call the handleKeyPress function\n\t// with the key value as parameter\n\t$('body').off('keyup');\n\t$('body').on('keyup', (e) => {\n\t\t// prevent scrolling\n\t\tif (['Space', 'ArrowUp', 'ArrowDown'].indexOf(e.code) > -1) {\n\t\t\tconsole.log(e);\n\t\t\te.preventDefault();\n\t\t}\n\t\thandleKeyPress(e.key);\n\t});\n\n\t// ========== END OF FUNCTIONALITY ==========\n\n\treturn (\n\t\t<div id='game'>\n\t\t\t<h1>2048</h1>\n\t\t\t{board && (\n\t\t\t\t<Grid\n\t\t\t\t\ttiles={board.tiles}\n\t\t\t\t\tscore={board.score}\n\t\t\t\t\tbest={board.best}\n\t\t\t\t\thandleKeyPress={handleKeyPress}\n\t\t\t\t/>\n\t\t\t)}\n\t\t\t{board && (\n\t\t\t\t<Arrows up={moveUp} right={moveRight} down={moveDown} left={moveLeft} />\n\t\t\t)}\n\t\t\t<Instruction />\n\t\t</div>\n\t);\n};\n\nexport default Game;\n","import './App.css';\nimport Game from './Game';\n\nfunction App() {\n\treturn (\n\t\t<div id='App'>\n\t\t\t<Game />\n\t\t</div>\n\t);\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}