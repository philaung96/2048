{"version":3,"sources":["TopTen.js","Instruction.js","Grid.js","Arrows.js","Game.js","App.js","index.js"],"names":["TopTen","props","leadersJsx","topTen","leaders","length","splice","map","user","index","className","name","score","id","Instruction","href","target","rel","Grid","tilesJsx","tiles","tile","Arrows","onClick","up","right","down","left","Game","useState","board","setBoard","gameMessage","setGameMessage","currentScore","didMoved","useEffect","localStorage","data","localData","JSON","parse","getItem","localTiles","best","localBest","localScore","initBoard","random","Math","floor","tilesArr","i","setItem","stringify","every","isMovable","bottomMovable","rightMovable","initialRow","movable","$","slideDown","messages","position","findIndex","push","slideUp","difference","gameOver","handleRestart","fadeOut","updateBoard","maxScore","oneDIndex","row","col","combineTwoTiles","from","to","total","findNumOnLeft","currentRow","exit","moveRight","currentIndex","indexOnLeft","findNumOnRight","moveLeft","indexOnRight","findNumBelow","below","moveUp","indexBelow","findNumAbove","above","moveDown","indexAbove","handleKeyPress","key","off","on","e","preventDefault","gameMessageJsx","message","onSubmit","inputName","val","fetch","headers","Accept","method","body","admin","process","attr","addClass","type","placeholder","latest","App","leaderboard","setLeaderboard","then","res","json","result","users","sort","a","b","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.3fef3b42.chunk.js","sourcesContent":["const TopTen = (props) => {\n\tlet leadersJsx = [];\n\tconst topTen = [...props.leaders];\n\n\t// If leaderboard has more than 10 users, chop the\n\t// array to 10\n\tif (topTen.length > 10) topTen.splice(10, props.leaders.length - 10);\n\n\t// Map through the top 10 users and creat a list\n\t// element to display on site\n\tleadersJsx = topTen.map((user, index) => (\n\t\t<li className='user-info' key={index}>\n\t\t\t<p>\n\t\t\t\t{index + 1} - {user.name} : {user.score}\n\t\t\t</p>\n\t\t</li>\n\t));\n\n\treturn (\n\t\t<section id='leaderboard'>\n\t\t\t<h2>TOP 10</h2>\n\t\t\t<ul id='top-ten'>{leadersJsx}</ul>\n\t\t</section>\n\t);\n};\n\nexport default TopTen;\n","const Instruction = () => {\n\treturn (\n\t\t<aside id='instruction'>\n\t\t\t<h2>How To Play</h2>\n\t\t\t<p>\n\t\t\t\t- Use <i>Arrow Keys</i>\n\t\t\t\t<span id='arrows-p'>\n\t\t\t\t\t, Or <i>Arrow Buttons</i>\n\t\t\t\t</span>{' '}\n\t\t\t\tTo Move The Tiles.\n\t\t\t\t<br />\n\t\t\t\t- Tiles With The Same Number Will Combine Into One.\n\t\t\t\t<br />\n\t\t\t\tCheck Out The Git Hub Repo\n\t\t\t\t<br />\n\t\t\t\t<a\n\t\t\t\t\thref='https://github.com/philaung96/2048'\n\t\t\t\t\ttarget='_blank'\n\t\t\t\t\trel='noreferrer'>\n\t\t\t\t\t<i>HERE</i>\n\t\t\t\t</a>\n\t\t\t</p>\n\t\t</aside>\n\t);\n};\n\nexport default Instruction;\n","const Grid = (props) => {\n\tlet tilesJsx = [];\n\n\tif (props.tiles)\n\t\ttilesJsx = props.tiles.map((tile, index) => (\n\t\t\t<div className='tile' key={index}>\n\t\t\t\t<h4>{tile ? tile : ''}</h4>\n\t\t\t</div>\n\t\t));\n\treturn <div id='grid'>{tilesJsx && tilesJsx}</div>;\n};\n\nexport default Grid;\n","const Arrows = (props) => {\n\treturn (\n\t\t<div id='arrows'>\n\t\t\t<div id='arrow-top' onClick={() => props.up()}>\n\t\t\t\t<i className='far fa-arrow-alt-circle-up fa-4x'></i>\n\t\t\t</div>\n\t\t\t<div id='arrow-right' onClick={() => props.right()}>\n\t\t\t\t<i className='far fa-arrow-alt-circle-right fa-4x'></i>\n\t\t\t</div>\n\t\t\t<div id='arrow-bottom' onClick={() => props.down()}>\n\t\t\t\t<i className='far fa-arrow-alt-circle-down fa-4x'></i>\n\t\t\t</div>\n\t\t\t<div id='arrow-left' onClick={() => props.left()}>\n\t\t\t\t<i className='far fa-arrow-alt-circle-left fa-4x'></i>\n\t\t\t</div>\n\t\t</div>\n\t);\n};\n\nexport default Arrows;\n","import Grid from './Grid';\nimport Arrows from './Arrows';\nimport { useState, useEffect } from 'react';\nimport $ from 'jquery';\n\nconst Game = (props) => {\n\tconst [board, setBoard] = useState();\n\tconst [gameMessage, setGameMessage] = useState([]);\n\n\tlet tiles = [];\n\tlet currentScore = 0;\n\tlet didMoved = false;\n\n\tif (board) {\n\t\ttiles = [...board.tiles];\n\t\tcurrentScore = board.score;\n\t}\n\n\t// ********** COMPONENT RERENDER FUNCTIONS **********\n\n\t// on initial load\n\tuseEffect(() => {\n\t\t// if there is data in local storage grab that data and update state\n\t\tif (localStorage.data) {\n\t\t\tconst localData = JSON.parse(localStorage.getItem('data'));\n\t\t\tsetBoard({\n\t\t\t\ttiles: [...localData.localTiles],\n\t\t\t\tbest: localData.localBest,\n\t\t\t\tscore: localData.localScore,\n\t\t\t});\n\t\t}\n\t\t// else keep current state data\n\t\telse initBoard();\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, []);\n\n\t// Initialize the Board\n\tconst initBoard = () => {\n\t\t// create a random index from 0-15\n\t\tlet random = Math.floor(Math.random() * 16);\n\t\tconst tilesArr = [];\n\t\t// place 2 at the random index\n\t\t// and 0 at the rest\n\t\tfor (let i = 0; i < 16; i++) {\n\t\t\tif (i === random) tilesArr[i] = 2;\n\t\t\telse tilesArr[i] = 0;\n\t\t}\n\t\tconst data = JSON.parse(localStorage.getItem('data'));\n\t\tlet localBest = 0;\n\t\tif (data) localBest = data.localBest;\n\t\tlocalStorage.setItem(\n\t\t\t'data',\n\t\t\tJSON.stringify({\n\t\t\t\tlocalTiles: [...tiles],\n\t\t\t\tlocalBest: localBest,\n\t\t\t\tlocalScore: currentScore,\n\t\t\t})\n\t\t);\n\t\t// update the state for component to rerender\n\t\tsetBoard({\n\t\t\ttiles: tilesArr,\n\t\t\tbest: localBest,\n\t\t\tscore: 0,\n\t\t});\n\t};\n\n\t//**** WRONG ATM OFF BY ONE MOVE */\n\t// Check if any tile is movable to bottom or right\n\t// only bottom or right since the iteration is done\n\t// top to bottom, left to right\n\t// Should only be called when all tiles are populated\n\t// return -> boolean\n\tconst movable = () => {\n\t\tlet isMovable = false;\n\n\t\t// checks if the tile below is same as tile at\n\t\t// index\n\t\t// index -> index of a tile -> int\n\t\t// return -> true if two tiles are same else\n\t\t// false\n\t\tconst bottomMovable = (index) => {\n\t\t\t// if the bottom tile exist and the bottom\n\t\t\t// tile has same value as tile at index,\n\t\t\t// return true. If not, return false\n\t\t\tif (index + 4 <= 15 && tiles[index] === tiles[index + 4]) return true;\n\t\t\telse return false;\n\t\t};\n\n\t\t// checks if the tile on right is same as tile at\n\t\t// index\n\t\t// index -> index of a tile -> int\n\t\t// return -> true if two tiles are same else\n\t\t// false\n\t\tconst rightMovable = (index) => {\n\t\t\tconst initialRow = Math.floor(index / 4);\n\t\t\t// if the tile at right is not on same row as\n\t\t\t// current tile or current tile and tile on\n\t\t\t// right are not the same, return false. If\n\t\t\t// not, return true\n\t\t\tif (\n\t\t\t\tMath.floor((index + 1) / 4) !== initialRow ||\n\t\t\t\ttiles[index] !== tiles[index + 1]\n\t\t\t)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t};\n\n\t\t// no need to check last index since the one\n\t\t// before last will check if they are the same\n\t\tfor (let index = 0; index < 15; index++) {\n\t\t\t// if any tile on bottom or right is same as\n\t\t\t// current tile set return value true and\n\t\t\t// quite iterating over tiles\n\t\t\tif (bottomMovable(index) || rightMovable(index)) {\n\t\t\t\tisMovable = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// return false by default\n\t\treturn isMovable;\n\t};\n\n\t// followup after game is over\n\tconst gameOver = () => {\n\t\t// Show the game over message\n\t\t$('#game-over').slideDown();\n\n\t\t// Set the game over message\n\t\tconst messages = ['!!! GAME OVER !!!'];\n\n\t\t// Find the position of current score on\n\t\t// leaderboard\n\t\tconst position = props.leaders.findIndex(\n\t\t\t(user) => currentScore > user.score\n\t\t);\n\n\t\t// If current score is within top 100\n\t\t// let the user know and display position\n\t\tif (position > -1 && position <= 9) {\n\t\t\tmessages.push(`Congratulations! you place ${position + 1} on Top 10`);\n\n\t\t\t// Hide the restart button so user can't\n\t\t\t// accidentally restart without add their\n\t\t\t// name to top 100 list\n\t\t\t$('#restart').slideUp();\n\t\t} else {\n\t\t\t// Hide submit form\n\t\t\t$('#game-over form').slideUp();\n\t\t\t// Check how many points current score is\n\t\t\t// off from the last position in leaderboard\n\t\t\tlet difference = 0;\n\t\t\tif (props.leaders[9]) difference = props.leaders[9].score - currentScore;\n\t\t\tmessages.push(`You are ${difference} points off from top 10`);\n\t\t}\n\t\tsetGameMessage(messages);\n\t};\n\n\t// if every tile is populated, and no\n\t// possibility to move any way, game over\n\t// checks after board is updated\n\tuseEffect(() => {\n\t\tif (tiles.every((tile) => tile > 0) && !movable()) gameOver();\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, [board, props]);\n\n\t// restarts the game: reinitialize the board\n\tconst handleRestart = () => {\n\t\t// Hide the game over message\n\t\t$('#game-over').fadeOut();\n\t\t// Clear current data\n\t\tconst random = Math.floor(Math.random() * 16);\n\t\ttiles = [];\n\t\tfor (let i = 0; i < 16; i++) {\n\t\t\tif (i === random) tiles[i] = 2;\n\t\t\telse tiles[i] = 0;\n\t\t}\n\t\tcurrentScore = 0;\n\t\t// Initialize the board\n\t\tinitBoard();\n\t};\n\n\t// handle when user add their name to top 100\n\t// after game over\n\tconst handleGameOverSubmit = (e) => {\n\t\te.preventDefault();\n\t\tconst inputName = $('#input-name').val();\n\n\t\t// if the name is submitted\n\t\tif (inputName) {\n\t\t\t// show the restart button\n\t\t\t$('#restart').slideDown();\n\t\t\t// add the name and score to database\n\t\t\tfetch('https://clone48.herokuapp.com', {\n\t\t\t\theaders: {\n\t\t\t\t\tAccept: 'application/json',\n\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t},\n\t\t\t\tmethod: 'POST',\n\t\t\t\tbody: JSON.stringify({\n\t\t\t\t\tadmin: process.env.REACT_APP_ADMIN_KEY,\n\t\t\t\t\tuser: {\n\t\t\t\t\t\tname: inputName,\n\t\t\t\t\t\tscore: currentScore,\n\t\t\t\t\t},\n\t\t\t\t}),\n\t\t\t});\n\t\t\t// restart the game\n\t\t\thandleRestart();\n\t\t}\n\t\t// if the input name is empty, do nothing and let\n\t\t// user know to put a name\n\t\telse {\n\t\t\t$('#input-name').attr('placeholder', 'please enter a name!');\n\t\t\t$('#input-name').addClass('red-placeholder');\n\t\t}\n\t};\n\n\t// Update the state for component to rerender the\n\t// update tiles\n\tconst updateBoard = () => {\n\t\t// get a random value between 0-15\n\t\tlet random = Math.floor(Math.random() * 16);\n\n\t\t// keep getting random value till there is an empty spot\n\t\twhile (tiles[random] > 0) {\n\t\t\trandom = Math.floor(Math.random() * 16);\n\t\t}\n\n\t\t// populate the empty spot\n\t\ttiles[random] = 2;\n\n\t\t// ========== LOCAL STORAGE ==========\n\t\tconst localData = JSON.parse(localStorage.getItem('data'));\n\n\t\t// if current score is higher than one in local\n\t\t// save current as best else keep local best\n\t\tlet maxScore = 0;\n\t\tcurrentScore > localData.localBest\n\t\t\t? (maxScore = currentScore)\n\t\t\t: (maxScore = localData.localBest);\n\n\t\t// store data to localStorage before changing\n\t\t// state\n\t\tlocalStorage.setItem(\n\t\t\t'data',\n\t\t\tJSON.stringify({\n\t\t\t\tlocalTiles: [...tiles],\n\t\t\t\tlocalBest: maxScore,\n\t\t\t\tlocalScore: currentScore,\n\t\t\t})\n\t\t);\n\t\t// ========== LOCAL STORAGE ==========\n\n\t\t// update the state for component to\n\t\t// rerender\n\t\tsetBoard({\n\t\t\ttiles: tiles,\n\t\t\tbest: maxScore,\n\t\t\tscore: currentScore,\n\t\t});\n\t};\n\n\t// ********** HELPER FUNCTIONS **********\n\n\t// translate rows and cols into one dimensional index\n\tconst oneDIndex = (row, col) => {\n\t\treturn row * 4 + col;\n\t};\n\n\t// Combine two tiles into one by indices\n\t// from -> index of tile combining from -> int\n\t// to -> index of tile combining into -> int\n\tconst combineTwoTiles = (from, to) => {\n\t\tlet total = tiles[to] + tiles[from];\n\t\t// if the tiles combine, update score\n\t\tif (tiles[to] === tiles[from]) currentScore += total;\n\t\t// combine two tiles into 'to' index\n\t\ttiles[to] = total;\n\t\t// empty the tile at 'from' index\n\t\ttiles[from] = 0;\n\t\t// set didMoved to true for component to rerender\n\t\tdidMoved = true;\n\t};\n\n\t// ********** MOVEMENTS **********\n\n\t// ========== MOVING TILES TO RIGHT ==========\n\n\t// Find the index of a tile that isn't zero on left\n\t// of given index\n\t// index -> index of a tile -> int\n\t// return -> index of a tile if found else -1\n\tconst findNumOnLeft = (index) => {\n\t\t// keep track of the current row\n\t\tconst currentRow = Math.floor(index / 4);\n\t\t// one index left of given index\n\t\tlet left = index - 1;\n\t\t// condition to exit the loop\n\t\tlet exit = false;\n\t\twhile (!exit) {\n\t\t\t// if the tile on left is not 0, return that\n\t\t\t// index\n\t\t\tif (tiles[left] > 0) return left;\n\t\t\t// keep going left\n\t\t\tleft--;\n\t\t\t// if there is no more tile on left to go or\n\t\t\t// index is out of current row, exit the loop\n\t\t\tif (left < 0 || Math.floor(left / 4) !== currentRow) exit = true;\n\t\t}\n\t\treturn -1;\n\t};\n\n\t// Move the individual tiles to right if possible\n\t// go through each row, then every columns of that\n\t// row, then move none 0 tiles to right if there is\n\t// a space\n\tconst moveRight = () => {\n\t\t// iterate through each rows\n\t\tfor (let row = 0; row < 4; row++) {\n\t\t\t// iterate through columns from right to left\n\t\t\t// excluding the first column\n\t\t\tfor (let col = 3; col >= 1; col--) {\n\t\t\t\t// one dimensional index of the tile\n\t\t\t\tlet currentIndex = oneDIndex(row, col);\n\t\t\t\t// find a non empty tile on left of\n\t\t\t\t// current\n\t\t\t\tlet indexOnLeft = findNumOnLeft(currentIndex);\n\t\t\t\t// found\n\t\t\t\tif (indexOnLeft !== -1) {\n\t\t\t\t\t// check if current tile is zero\n\t\t\t\t\t// if zero, move tile found on left\n\t\t\t\t\t// into current\n\t\t\t\t\tif (tiles[currentIndex] === 0) {\n\t\t\t\t\t\tcombineTwoTiles(indexOnLeft, currentIndex);\n\t\t\t\t\t\t// stay at current place and\n\t\t\t\t\t\t// check one more time\n\t\t\t\t\t\tcol++;\n\t\t\t\t\t}\n\t\t\t\t\t// is not zero\n\t\t\t\t\telse {\n\t\t\t\t\t\t// if tile found on left is same\n\t\t\t\t\t\t// as current, combine tile on\n\t\t\t\t\t\t// left into current\n\t\t\t\t\t\tif (tiles[currentIndex] === tiles[indexOnLeft])\n\t\t\t\t\t\t\tcombineTwoTiles(indexOnLeft, currentIndex);\n\t\t\t\t\t\t// if tile found on left and\n\t\t\t\t\t\t// current are not same, and\n\t\t\t\t\t\t// tile on left is not one\n\t\t\t\t\t\t// position left of current,\n\t\t\t\t\t\t// move tile on left into one\n\t\t\t\t\t\t// tile left of current\n\t\t\t\t\t\telse if (currentIndex - 1 !== indexOnLeft)\n\t\t\t\t\t\t\tcombineTwoTiles(indexOnLeft, currentIndex - 1);\n\t\t\t\t\t\t// else do nothing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if not found do nothing\n\t\t\t}\n\t\t}\n\t\t// update the state to rerender the component\n\t\t// if the tile(s) moved\n\t\tif (didMoved) updateBoard();\n\t};\n\n\t// ========== MOVING TILES TO LEFT ==========\n\n\t// Find the index of a tile that isn't zero on right\n\t// of given index\n\t// index -> index of a tile -> int\n\t// return -> index of a tile if found else -1\n\tconst findNumOnRight = (index) => {\n\t\t// keep track of the current row\n\t\tconst currentRow = Math.floor(index / 4);\n\t\t// one index right of given index\n\t\tlet right = index + 1;\n\t\t// condition to exit the loop\n\t\tlet exit = false;\n\t\twhile (!exit) {\n\t\t\t// if the tile on right is not 0, return\n\t\t\t// that index\n\t\t\tif (tiles[right] > 0) return right;\n\t\t\t// keep going right\n\t\t\tright++;\n\t\t\t// if there is no more tile on left to go or\n\t\t\t// index is out of current row, exit the loop\n\t\t\tif (right > 15 || Math.floor(right / 4) !== currentRow) exit = true;\n\t\t}\n\t\treturn -1;\n\t};\n\n\t// Move the individual tiles to left if possible\n\t// go through each row, then every columns of that\n\t// row, then move none 0 tiles to left if there is\n\t// a space\n\tconst moveLeft = () => {\n\t\t// iterate through each rows\n\t\tfor (let row = 0; row < 4; row++) {\n\t\t\t// iterate through columns from left to right\n\t\t\t// excluding the last column\n\t\t\tfor (let col = 0; col < 3; col++) {\n\t\t\t\t// one dimensional index of the tile\n\t\t\t\tlet currentIndex = oneDIndex(row, col);\n\t\t\t\t// find a non empty tile on right of\n\t\t\t\t// current\n\t\t\t\tlet indexOnRight = findNumOnRight(currentIndex);\n\t\t\t\t// found\n\t\t\t\tif (indexOnRight !== -1) {\n\t\t\t\t\t// check if current tile is zero\n\t\t\t\t\t// if zero, move tile found on right\n\t\t\t\t\t// into current\n\t\t\t\t\tif (tiles[currentIndex] === 0) {\n\t\t\t\t\t\tcombineTwoTiles(indexOnRight, currentIndex);\n\t\t\t\t\t\t// stay at current place and\n\t\t\t\t\t\t// check one more time\n\t\t\t\t\t\tcol--;\n\t\t\t\t\t}\n\t\t\t\t\t// is not zero\n\t\t\t\t\telse {\n\t\t\t\t\t\t// if tile found on right is same\n\t\t\t\t\t\t// as current, combine tile on\n\t\t\t\t\t\t// right into current\n\t\t\t\t\t\tif (tiles[currentIndex] === tiles[indexOnRight])\n\t\t\t\t\t\t\tcombineTwoTiles(indexOnRight, currentIndex);\n\t\t\t\t\t\t// if tile found on right and\n\t\t\t\t\t\t// current are not same, and\n\t\t\t\t\t\t// tile on right is not one\n\t\t\t\t\t\t// position right of current,\n\t\t\t\t\t\t// move tile on right into one\n\t\t\t\t\t\t// tile right of current\n\t\t\t\t\t\telse if (currentIndex + 1 !== indexOnRight)\n\t\t\t\t\t\t\tcombineTwoTiles(indexOnRight, currentIndex + 1);\n\t\t\t\t\t\t// else do nothing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if not found do nothing\n\t\t\t}\n\t\t}\n\t\t// update the state to rerender the component\n\t\t// if the tile(s) moved\n\t\tif (didMoved) updateBoard();\n\t};\n\n\t// ========== MOVING TILES UP ==========\n\n\t// Find the index of a tile that isn't zero on bottom\n\t// of given index\n\t// index -> index of a tile -> int\n\t// return -> index of a tile if found else -1\n\tconst findNumBelow = (index) => {\n\t\t// tile that is one below the index\n\t\tlet below = index + 4;\n\t\t// condition to exit the loop\n\t\tlet exit = false;\n\t\twhile (!exit) {\n\t\t\t// if the tile below is not 0, return that\n\t\t\t// index\n\t\t\tif (tiles[below] > 0) return below;\n\t\t\t// keep going below\n\t\t\tbelow += 4;\n\t\t\t// if there is no more tiles below,\n\t\t\t// exit the loop\n\t\t\tif (below > 15) exit = true;\n\t\t}\n\t\treturn -1;\n\t};\n\n\t// Move the individual tiles to up if possible\n\t// go through each col, then every rows that\n\t// contains that col , then move none 0 tiles up\n\t// if there is a space\n\tconst moveUp = () => {\n\t\t// iterate through each columns left to right\n\t\tfor (let col = 0; col < 4; col++) {\n\t\t\t// iterate through rows from top to bottom\n\t\t\t// excluding the last row\n\t\t\tfor (let row = 0; row < 3; row++) {\n\t\t\t\t// one dimensional index of the tile\n\t\t\t\tlet currentIndex = oneDIndex(row, col);\n\t\t\t\t// find a non empty tile below of current\n\t\t\t\tlet indexBelow = findNumBelow(currentIndex);\n\t\t\t\t// found\n\t\t\t\tif (indexBelow !== -1) {\n\t\t\t\t\t// check if current tile is zero\n\t\t\t\t\t// if zero, move tile found below\n\t\t\t\t\t// into current\n\t\t\t\t\tif (tiles[currentIndex] === 0) {\n\t\t\t\t\t\tcombineTwoTiles(indexBelow, currentIndex);\n\t\t\t\t\t\t// stay at current place and\n\t\t\t\t\t\t// check one more time\n\t\t\t\t\t\trow--;\n\t\t\t\t\t}\n\t\t\t\t\t// is not zero\n\t\t\t\t\telse {\n\t\t\t\t\t\t// if tile found below is same as\n\t\t\t\t\t\t// current, combine tile below\n\t\t\t\t\t\t// into current\n\t\t\t\t\t\tif (tiles[currentIndex] === tiles[indexBelow])\n\t\t\t\t\t\t\tcombineTwoTiles(indexBelow, currentIndex);\n\t\t\t\t\t\t// if tile found below and\n\t\t\t\t\t\t// current are not same, and\n\t\t\t\t\t\t// tile below is not one row\n\t\t\t\t\t\t// below of current, move below\n\t\t\t\t\t\t// into one tile below current\n\t\t\t\t\t\telse if (currentIndex + 4 !== indexBelow)\n\t\t\t\t\t\t\tcombineTwoTiles(indexBelow, currentIndex + 4);\n\t\t\t\t\t\t// else do nothing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if not found do nothing\n\t\t\t}\n\t\t}\n\t\t// update the state to rerender the component\n\t\t// if the tile(s) moved\n\t\tif (didMoved) updateBoard();\n\t};\n\n\t// ========== MOVING TILES DOWN ==========\n\n\t// Find the index of a tile that isn't zero on above\n\t// of given index\n\t// index -> index of a tile -> int\n\t// return -> index of a tile if found else -1\n\tconst findNumAbove = (index) => {\n\t\t// tile that is one above the index\n\t\tlet above = index - 4;\n\t\t// condition to exit the loop\n\t\tlet exit = false;\n\t\twhile (!exit) {\n\t\t\t// if the tile above is not 0, return that\n\t\t\t// index\n\t\t\tif (tiles[above] > 0) return above;\n\t\t\t// keep going above\n\t\t\tabove -= 4;\n\t\t\t// if there is no more tiles above,\n\t\t\t// exit the loop\n\t\t\tif (above < 0) exit = true;\n\t\t}\n\t\treturn -1;\n\t};\n\n\t// Move the individual tiles down if possible\n\t// go through each col, then every rows that\n\t// contains that col , then move none 0 tiles down\n\t// if there is a space\n\tconst moveDown = () => {\n\t\t// iterate through each columns left to right\n\t\tfor (let col = 0; col < 4; col++) {\n\t\t\t// iterate through rows from top to bottom\n\t\t\t// excluding the first row\n\t\t\tfor (let row = 3; row > 0; row--) {\n\t\t\t\t// one dimensional index of the tile\n\t\t\t\tlet currentIndex = oneDIndex(row, col);\n\t\t\t\t// find a non empty tile above of current\n\t\t\t\tlet indexAbove = findNumAbove(currentIndex);\n\t\t\t\t// found\n\t\t\t\tif (indexAbove !== -1) {\n\t\t\t\t\t// check if current tile is zero\n\t\t\t\t\t// if zero, move tile found above\n\t\t\t\t\t// into current\n\t\t\t\t\tif (tiles[currentIndex] === 0) {\n\t\t\t\t\t\tcombineTwoTiles(indexAbove, currentIndex);\n\t\t\t\t\t\t// stay at current place and\n\t\t\t\t\t\t// check one more time\n\t\t\t\t\t\trow++;\n\t\t\t\t\t}\n\t\t\t\t\t// is not zero\n\t\t\t\t\telse {\n\t\t\t\t\t\t// if tile found above is same as\n\t\t\t\t\t\t// current, combine tile above\n\t\t\t\t\t\t// into current\n\t\t\t\t\t\tif (tiles[currentIndex] === tiles[indexAbove])\n\t\t\t\t\t\t\tcombineTwoTiles(indexAbove, currentIndex);\n\t\t\t\t\t\t// if tile found above and\n\t\t\t\t\t\t// current are not same, and\n\t\t\t\t\t\t// tile above is not one row\n\t\t\t\t\t\t// above of current, move above\n\t\t\t\t\t\t// into one tile above current\n\t\t\t\t\t\telse if (currentIndex - 4 !== indexAbove)\n\t\t\t\t\t\t\tcombineTwoTiles(indexAbove, currentIndex - 4);\n\t\t\t\t\t\t// else do nothing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if not found do nothing\n\t\t\t}\n\t\t}\n\t\t// update the state to rerender the component\n\t\t// if the tile(s) moved\n\t\tif (didMoved) updateBoard();\n\t};\n\n\t// ********** HANDLE KEY PRESS **********\n\n\t// Take action accordingly after user pressed a key\n\t// key -> key pressed by user -> string\n\tconst handleKeyPress = (key) => {\n\t\tswitch (key) {\n\t\t\t// left arrow key pressed\n\t\t\t// move the tiles to left if possible\n\t\t\tcase 'ArrowLeft':\n\t\t\t\tmoveLeft();\n\t\t\t\tbreak;\n\t\t\t// up arrow key pressed\n\t\t\t// move the tiles up if possible\n\t\t\tcase 'ArrowUp':\n\t\t\t\tmoveUp();\n\t\t\t\tbreak;\n\t\t\t// right arrow key pressed\n\t\t\t// move the tiles to right if possible\n\t\t\tcase 'ArrowRight':\n\t\t\t\tmoveRight();\n\t\t\t\tbreak;\n\t\t\t// down arrow key pressed\n\t\t\t// move the tiles down if possible\n\t\t\tcase 'ArrowDown':\n\t\t\t\tmoveDown();\n\t\t\t\tbreak;\n\t\t\t// Do nothing for the rest of the key\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\t// on key press, call the handleKeyPress function\n\t// with the key value as parameter\n\t$('body').off('keyup');\n\t$('body').on('keyup', (e) => {\n\t\t// prevent scrolling\n\t\te.preventDefault();\n\t\thandleKeyPress(e.key);\n\t});\n\n\t// A message to let user know when they win or lose\n\tlet gameMessageJsx = gameMessage.map((message, index) => (\n\t\t<h3 key={index}>{message}</h3>\n\t));\n\n\t// ========== END OF FUNCTIONALITY ==========\n\n\treturn (\n\t\t<section id='game'>\n\t\t\t<div id='game-over'>\n\t\t\t\t{gameMessageJsx}\n\t\t\t\t<form onSubmit={handleGameOverSubmit}>\n\t\t\t\t\t<fieldset>\n\t\t\t\t\t\t<legend>Add Your Name To Leaderboard</legend>\n\t\t\t\t\t\t<input type='text' placeholder='name' id='input-name' />\n\t\t\t\t\t\t<button type='submit'>submit</button>\n\t\t\t\t\t</fieldset>\n\t\t\t\t</form>\n\t\t\t</div>\n\t\t\t{board && (\n\t\t\t\t<div id='scores'>\n\t\t\t\t\t<h4 className='score'>best : {board.best}</h4>\n\t\t\t\t\t<h4 className='score'>score : {board.score}</h4>\n\t\t\t\t\t<button id='restart' onClick={handleRestart}>\n\t\t\t\t\t\trestart\n\t\t\t\t\t</button>\n\t\t\t\t</div>\n\t\t\t)}\n\t\t\t{board && (\n\t\t\t\t<Grid\n\t\t\t\t\ttiles={board.tiles}\n\t\t\t\t\tlatest={board.latest}\n\t\t\t\t\thandleKeyPress={handleKeyPress}\n\t\t\t\t/>\n\t\t\t)}\n\t\t\t{board && (\n\t\t\t\t<Arrows up={moveUp} right={moveRight} down={moveDown} left={moveLeft} />\n\t\t\t)}\n\t\t</section>\n\t);\n};\n\nexport default Game;\n","import './App.css';\nimport TopTen from './TopTen';\nimport Instruction from './Instruction';\nimport Game from './Game';\nimport { useState, useEffect } from 'react';\n\nfunction App() {\n\tconst apiURL = 'https://clone48.herokuapp.com';\n\tconst [leaderboard, setLeaderboard] = useState([]);\n\n\tuseEffect(() => {\n\t\t// fetch scores from database\n\t\tfetch(apiURL)\n\t\t\t.then((res) => res.json()) //turn data into json\n\t\t\t.then((data) => {\n\t\t\t\tconst result = data.users;\n\t\t\t\t// sort the data by score from largest to smallest\n\t\t\t\tresult.sort((a, b) => b.score - a.score);\n\t\t\t\tsetLeaderboard(result);\n\t\t\t});\n\t}, []);\n\n\treturn (\n\t\t<div id='App'>\n\t\t\t<h1>2048</h1>\n\t\t\t<main>\n\t\t\t\t<Game leaders={leaderboard} />\n\t\t\t\t<TopTen leaders={leaderboard} />\n\t\t\t\t<Instruction />\n\t\t\t</main>\n\t\t</div>\n\t);\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}