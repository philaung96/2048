{"version":3,"sources":["Grid.js","Arrows.js","Instruction.js","Game.js","App.js","index.js"],"names":["Grid","props","tilesJsx","tiles","map","tile","index","className","id","Arrows","onClick","up","right","down","left","Instruction","href","target","rel","Game","useState","board","setBoard","gameMessage","setGameMessage","currentScore","didMoved","score","useEffect","localStorage","data","localData","JSON","parse","getItem","localTiles","best","localBest","localScore","initBoard","random","Math","floor","tilesArr","i","setItem","stringify","every","isMovable","bottomMovable","rightMovable","initialRow","movable","console","log","$","slideDown","updateBoard","maxScore","oneDIndex","row","col","combineTwoTiles","from","to","total","findNumOnLeft","currentRow","exit","moveRight","currentIndex","indexOnLeft","findNumOnRight","moveLeft","indexOnRight","findNumBelow","below","moveUp","indexBelow","findNumAbove","above","moveDown","indexAbove","handleKeyPress","key","off","on","e","preventDefault","fadeOut","latest","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.49e4cfb1.chunk.js","sourcesContent":["const Grid = (props) => {\n\tlet tilesJsx = [];\n\n\tif (props.tiles)\n\t\ttilesJsx = props.tiles.map((tile, index) => (\n\t\t\t<div className='tile' key={index}>\n\t\t\t\t<h2>{tile ? tile : ''}</h2>\n\t\t\t</div>\n\t\t));\n\treturn <div id='grid'>{tilesJsx && tilesJsx}</div>;\n};\n\nexport default Grid;\n","const Arrows = (props) => {\n\treturn (\n\t\t<div id='arrows'>\n\t\t\t<div id='arrow-top' onClick={() => props.up()}>\n\t\t\t\t<i className='far fa-arrow-alt-circle-up fa-3x'></i>\n\t\t\t</div>\n\t\t\t<div id='arrow-right' onClick={() => props.right()}>\n\t\t\t\t<i className='far fa-arrow-alt-circle-right fa-3x'></i>\n\t\t\t</div>\n\t\t\t<div id='arrow-bottom' onClick={() => props.down()}>\n\t\t\t\t<i className='far fa-arrow-alt-circle-down fa-3x'></i>\n\t\t\t</div>\n\t\t\t<div id='arrow-left' onClick={() => props.left()}>\n\t\t\t\t<i className='far fa-arrow-alt-circle-left fa-3x'></i>\n\t\t\t</div>\n\t\t</div>\n\t);\n};\n\nexport default Arrows;\n","const Instruction = () => {\n\treturn (\n\t\t<>\n\t\t\t<h2>How To Play</h2>\n\t\t\t<p>\n\t\t\t\tUse <i>Arrow Keys</i>, Or <i>Arrow Buttons</i> To Move The Tiles. Tiles\n\t\t\t\tWith The Same Number Will Combine Into One.\n\t\t\t\t<br />\n\t\t\t\tCheck Out The Git Hub Repo\n\t\t\t\t<br />\n\t\t\t\t<a\n\t\t\t\t\thref='https://github.com/philaung96/2048'\n\t\t\t\t\ttarget='_blank'\n\t\t\t\t\trel='noreferrer'>\n\t\t\t\t\t<i>HERE</i>\n\t\t\t\t</a>\n\t\t\t</p>\n\t\t</>\n\t);\n};\n\nexport default Instruction;\n","import Grid from './Grid';\nimport Arrows from './Arrows';\nimport Instruction from './Instruction';\nimport { useState, useEffect } from 'react';\nimport $ from 'jquery';\n\nconst Game = () => {\n\tconst [board, setBoard] = useState();\n\tconst [gameMessage, setGameMessage] = useState(null);\n\n\tlet tiles = [];\n\tlet currentScore = 0;\n\tlet didMoved = false;\n\n\tif (board) {\n\t\ttiles = [...board.tiles];\n\t\tcurrentScore = board.score;\n\t}\n\n\t// ********** COMPONENT RERENDER FUNCTIONS **********\n\n\t// on initial load\n\tuseEffect(() => {\n\t\t// if there is data in local storage grab that data and update state\n\t\tif (localStorage.data) {\n\t\t\tconst localData = JSON.parse(localStorage.getItem('data'));\n\t\t\tsetBoard({\n\t\t\t\ttiles: [...localData.localTiles],\n\t\t\t\tbest: localData.localBest,\n\t\t\t\tscore: localData.localScore,\n\t\t\t});\n\t\t}\n\t\t// else keep current state data\n\t\telse initBoard();\n\t}, []);\n\n\t// Initialize the Board\n\tconst initBoard = () => {\n\t\t// create a random index from 0-15\n\t\tlet random = Math.floor(Math.random() * 16);\n\t\tconst tilesArr = [];\n\t\t// place 2 at the random index\n\t\t// and 0 at the rest\n\t\tfor (let i = 0; i < 16; i++) {\n\t\t\tif (i === random) tilesArr[i] = 2;\n\t\t\telse tilesArr[i] = 0;\n\t\t}\n\t\tconst data = JSON.parse(localStorage.getItem('data'));\n\t\tlet localBest = 0;\n\t\tif (data) localBest = data.localBest;\n\t\tlocalStorage.setItem(\n\t\t\t'data',\n\t\t\tJSON.stringify({\n\t\t\t\tlocalTiles: [...tiles],\n\t\t\t\tlocalBest: localBest,\n\t\t\t\tlocalScore: currentScore,\n\t\t\t})\n\t\t);\n\t\t// update the state for component to rerender\n\t\tsetBoard({\n\t\t\ttiles: tilesArr,\n\t\t\tbest: localBest,\n\t\t\tscore: 0,\n\t\t});\n\t};\n\n\t//**** WRONG ATM OFF BY ONE MOVE */\n\t// Check if any tile is movable to bottom or right\n\t// only bottom or right since the iteration is done\n\t// top to bottom, left to right\n\t// Should only be called when all tiles are populated\n\t// return -> boolean\n\tconst movable = () => {\n\t\tlet isMovable = false;\n\n\t\t// checks if the tile below is same as tile at\n\t\t// index\n\t\t// index -> index of a tile -> int\n\t\t// return -> true if two tiles are same else\n\t\t// false\n\t\tconst bottomMovable = (index) => {\n\t\t\t// if the bottom tile exist and the bottom\n\t\t\t// tile has same value as tile at index,\n\t\t\t// return true. If not, return false\n\t\t\tif (index + 4 <= 15 && tiles[index] === tiles[index + 4]) return true;\n\t\t\telse return false;\n\t\t};\n\n\t\t// checks if the tile on right is same as tile at\n\t\t// index\n\t\t// index -> index of a tile -> int\n\t\t// return -> true if two tiles are same else\n\t\t// false\n\t\tconst rightMovable = (index) => {\n\t\t\tconst initialRow = Math.floor(index / 4);\n\t\t\t// if the tile at right is not on same row as\n\t\t\t// current tile or current tile and tile on\n\t\t\t// right are not the same, return false. If\n\t\t\t// not, return true\n\t\t\tif (\n\t\t\t\tMath.floor((index + 1) / 4) !== initialRow ||\n\t\t\t\ttiles[index] !== tiles[index + 1]\n\t\t\t)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t};\n\n\t\t// no need to check last index since the one\n\t\t// before last will check if they are the same\n\t\tfor (let index = 0; index < 15; index++) {\n\t\t\t// if any tile on bottom or right is same as\n\t\t\t// current tile set return value true and\n\t\t\t// quite iterating over tiles\n\t\t\tif (bottomMovable(index) || rightMovable(index)) {\n\t\t\t\tisMovable = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// return false by default\n\t\treturn isMovable;\n\t};\n\n\t// followup after game is over\n\tconst gameOver = () => {\n\t\tconsole.log('game over');\n\t\t$('.message').slideDown();\n\t\tsetGameMessage('Game Over');\n\t};\n\n\t// if every tile is populated, and no\n\t// possibility to move any way, game over\n\t// checks after board is updated\n\tuseEffect(() => {\n\t\tif (tiles.every((tile) => tile > 0) && !movable()) gameOver();\n\t}, [board]);\n\n\t// restarts the game: reinitialize the board\n\tconst handleRestart = () => {\n\t\t$('.message').fadeOut();\n\t\tinitBoard();\n\t};\n\n\t// Update the state for component to rerender the\n\t// update tiles\n\tconst updateBoard = () => {\n\t\t// get a random value between 0-15\n\t\tlet random = Math.floor(Math.random() * 16);\n\n\t\t// keep getting random value till there is an empty spot\n\t\twhile (tiles[random] > 0) {\n\t\t\trandom = Math.floor(Math.random() * 16);\n\t\t}\n\n\t\t// populate the empty spot\n\t\ttiles[random] = 2;\n\n\t\t// ========== LOCAL STORAGE ==========\n\t\tconst localData = JSON.parse(localStorage.getItem('data'));\n\n\t\t// if current score is higher than one in local\n\t\t// save current as best else keep local best\n\t\tlet maxScore = 0;\n\t\tcurrentScore > localData.localBest\n\t\t\t? (maxScore = currentScore)\n\t\t\t: (maxScore = localData.localBest);\n\n\t\t// store data to localStorage before changing\n\t\t// state\n\t\tlocalStorage.setItem(\n\t\t\t'data',\n\t\t\tJSON.stringify({\n\t\t\t\tlocalTiles: [...tiles],\n\t\t\t\tlocalBest: maxScore,\n\t\t\t\tlocalScore: currentScore,\n\t\t\t})\n\t\t);\n\t\t// ========== LOCAL STORAGE ==========\n\n\t\t// update the state for component to\n\t\t// rerender\n\t\tsetBoard({\n\t\t\ttiles: tiles,\n\t\t\tbest: maxScore,\n\t\t\tscore: currentScore,\n\t\t});\n\t};\n\n\t// ********** HELPER FUNCTIONS **********\n\n\t// translate rows and cols into one dimensional index\n\tconst oneDIndex = (row, col) => {\n\t\treturn row * 4 + col;\n\t};\n\n\t// Combine two tiles into one by indices\n\t// from -> index of tile combining from -> int\n\t// to -> index of tile combining into -> int\n\tconst combineTwoTiles = (from, to) => {\n\t\tlet total = tiles[to] + tiles[from];\n\t\t// if the tiles combine, update score\n\t\tif (tiles[to] === tiles[from]) currentScore += total;\n\t\t// combine two tiles into 'to' index\n\t\ttiles[to] = total;\n\t\t// empty the tile at 'from' index\n\t\ttiles[from] = 0;\n\t\t// set didMoved to true for component to rerender\n\t\tdidMoved = true;\n\t};\n\n\t// ********** MOVEMENTS **********\n\n\t// ========== MOVING TILES TO RIGHT ==========\n\n\t// Find the index of a tile that isn't zero on left\n\t// of given index\n\t// index -> index of a tile -> int\n\t// return -> index of a tile if found else -1\n\tconst findNumOnLeft = (index) => {\n\t\t// keep track of the current row\n\t\tconst currentRow = Math.floor(index / 4);\n\t\t// one index left of given index\n\t\tlet left = index - 1;\n\t\t// condition to exit the loop\n\t\tlet exit = false;\n\t\twhile (!exit) {\n\t\t\t// if the tile on left is not 0, return that\n\t\t\t// index\n\t\t\tif (tiles[left] > 0) return left;\n\t\t\t// keep going left\n\t\t\tleft--;\n\t\t\t// if there is no more tile on left to go or\n\t\t\t// index is out of current row, exit the loop\n\t\t\tif (left < 0 || Math.floor(left / 4) !== currentRow) exit = true;\n\t\t}\n\t\treturn -1;\n\t};\n\n\t// Move the individual tiles to right if possible\n\t// go through each row, then every columns of that\n\t// row, then move none 0 tiles to right if there is\n\t// a space\n\tconst moveRight = () => {\n\t\t// iterate through each rows\n\t\tfor (let row = 0; row < 4; row++) {\n\t\t\t// iterate through columns from right to left\n\t\t\t// excluding the first column\n\t\t\tfor (let col = 3; col >= 1; col--) {\n\t\t\t\t// one dimensional index of the tile\n\t\t\t\tlet currentIndex = oneDIndex(row, col);\n\t\t\t\t// find a non empty tile on left of\n\t\t\t\t// current\n\t\t\t\tlet indexOnLeft = findNumOnLeft(currentIndex);\n\t\t\t\t// found\n\t\t\t\tif (indexOnLeft !== -1) {\n\t\t\t\t\t// check if current tile is zero\n\t\t\t\t\t// if zero, move tile found on left\n\t\t\t\t\t// into current\n\t\t\t\t\tif (tiles[currentIndex] === 0) {\n\t\t\t\t\t\tcombineTwoTiles(indexOnLeft, currentIndex);\n\t\t\t\t\t\t// stay at current place and\n\t\t\t\t\t\t// check one more time\n\t\t\t\t\t\tcol++;\n\t\t\t\t\t}\n\t\t\t\t\t// is not zero\n\t\t\t\t\telse {\n\t\t\t\t\t\t// if tile found on left is same\n\t\t\t\t\t\t// as current, combine tile on\n\t\t\t\t\t\t// left into current\n\t\t\t\t\t\tif (tiles[currentIndex] === tiles[indexOnLeft])\n\t\t\t\t\t\t\tcombineTwoTiles(indexOnLeft, currentIndex);\n\t\t\t\t\t\t// if tile found on left and\n\t\t\t\t\t\t// current are not same, and\n\t\t\t\t\t\t// tile on left is not one\n\t\t\t\t\t\t// position left of current,\n\t\t\t\t\t\t// move tile on left into one\n\t\t\t\t\t\t// tile left of current\n\t\t\t\t\t\telse if (currentIndex - 1 !== indexOnLeft)\n\t\t\t\t\t\t\tcombineTwoTiles(indexOnLeft, currentIndex - 1);\n\t\t\t\t\t\t// else do nothing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if not found do nothing\n\t\t\t}\n\t\t}\n\t\t// update the state to rerender the component\n\t\t// if the tile(s) moved\n\t\tif (didMoved) updateBoard();\n\t};\n\n\t// ========== MOVING TILES TO LEFT ==========\n\n\t// Find the index of a tile that isn't zero on right\n\t// of given index\n\t// index -> index of a tile -> int\n\t// return -> index of a tile if found else -1\n\tconst findNumOnRight = (index) => {\n\t\t// keep track of the current row\n\t\tconst currentRow = Math.floor(index / 4);\n\t\t// one index right of given index\n\t\tlet right = index + 1;\n\t\t// condition to exit the loop\n\t\tlet exit = false;\n\t\twhile (!exit) {\n\t\t\t// if the tile on right is not 0, return\n\t\t\t// that index\n\t\t\tif (tiles[right] > 0) return right;\n\t\t\t// keep going right\n\t\t\tright++;\n\t\t\t// if there is no more tile on left to go or\n\t\t\t// index is out of current row, exit the loop\n\t\t\tif (right > 15 || Math.floor(right / 4) !== currentRow) exit = true;\n\t\t}\n\t\treturn -1;\n\t};\n\n\t// Move the individual tiles to left if possible\n\t// go through each row, then every columns of that\n\t// row, then move none 0 tiles to left if there is\n\t// a space\n\tconst moveLeft = () => {\n\t\t// iterate through each rows\n\t\tfor (let row = 0; row < 4; row++) {\n\t\t\t// iterate through columns from left to right\n\t\t\t// excluding the last column\n\t\t\tfor (let col = 0; col < 3; col++) {\n\t\t\t\t// one dimensional index of the tile\n\t\t\t\tlet currentIndex = oneDIndex(row, col);\n\t\t\t\t// find a non empty tile on right of\n\t\t\t\t// current\n\t\t\t\tlet indexOnRight = findNumOnRight(currentIndex);\n\t\t\t\t// found\n\t\t\t\tif (indexOnRight !== -1) {\n\t\t\t\t\t// check if current tile is zero\n\t\t\t\t\t// if zero, move tile found on right\n\t\t\t\t\t// into current\n\t\t\t\t\tif (tiles[currentIndex] === 0) {\n\t\t\t\t\t\tcombineTwoTiles(indexOnRight, currentIndex);\n\t\t\t\t\t\t// stay at current place and\n\t\t\t\t\t\t// check one more time\n\t\t\t\t\t\tcol--;\n\t\t\t\t\t}\n\t\t\t\t\t// is not zero\n\t\t\t\t\telse {\n\t\t\t\t\t\t// if tile found on right is same\n\t\t\t\t\t\t// as current, combine tile on\n\t\t\t\t\t\t// right into current\n\t\t\t\t\t\tif (tiles[currentIndex] === tiles[indexOnRight])\n\t\t\t\t\t\t\tcombineTwoTiles(indexOnRight, currentIndex);\n\t\t\t\t\t\t// if tile found on right and\n\t\t\t\t\t\t// current are not same, and\n\t\t\t\t\t\t// tile on right is not one\n\t\t\t\t\t\t// position right of current,\n\t\t\t\t\t\t// move tile on right into one\n\t\t\t\t\t\t// tile right of current\n\t\t\t\t\t\telse if (currentIndex + 1 !== indexOnRight)\n\t\t\t\t\t\t\tcombineTwoTiles(indexOnRight, currentIndex + 1);\n\t\t\t\t\t\t// else do nothing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if not found do nothing\n\t\t\t}\n\t\t}\n\t\t// update the state to rerender the component\n\t\t// if the tile(s) moved\n\t\tif (didMoved) updateBoard();\n\t};\n\n\t// ========== MOVING TILES UP ==========\n\n\t// Find the index of a tile that isn't zero on bottom\n\t// of given index\n\t// index -> index of a tile -> int\n\t// return -> index of a tile if found else -1\n\tconst findNumBelow = (index) => {\n\t\t// tile that is one below the index\n\t\tlet below = index + 4;\n\t\t// condition to exit the loop\n\t\tlet exit = false;\n\t\twhile (!exit) {\n\t\t\t// if the tile below is not 0, return that\n\t\t\t// index\n\t\t\tif (tiles[below] > 0) return below;\n\t\t\t// keep going below\n\t\t\tbelow += 4;\n\t\t\t// if there is no more tiles below,\n\t\t\t// exit the loop\n\t\t\tif (below > 15) exit = true;\n\t\t}\n\t\treturn -1;\n\t};\n\n\t// Move the individual tiles to up if possible\n\t// go through each col, then every rows that\n\t// contains that col , then move none 0 tiles up\n\t// if there is a space\n\tconst moveUp = () => {\n\t\t// iterate through each columns left to right\n\t\tfor (let col = 0; col < 4; col++) {\n\t\t\t// iterate through rows from top to bottom\n\t\t\t// excluding the last row\n\t\t\tfor (let row = 0; row < 3; row++) {\n\t\t\t\t// one dimensional index of the tile\n\t\t\t\tlet currentIndex = oneDIndex(row, col);\n\t\t\t\t// find a non empty tile below of current\n\t\t\t\tlet indexBelow = findNumBelow(currentIndex);\n\t\t\t\t// found\n\t\t\t\tif (indexBelow !== -1) {\n\t\t\t\t\t// check if current tile is zero\n\t\t\t\t\t// if zero, move tile found below\n\t\t\t\t\t// into current\n\t\t\t\t\tif (tiles[currentIndex] === 0) {\n\t\t\t\t\t\tcombineTwoTiles(indexBelow, currentIndex);\n\t\t\t\t\t\t// stay at current place and\n\t\t\t\t\t\t// check one more time\n\t\t\t\t\t\trow--;\n\t\t\t\t\t}\n\t\t\t\t\t// is not zero\n\t\t\t\t\telse {\n\t\t\t\t\t\t// if tile found below is same as\n\t\t\t\t\t\t// current, combine tile below\n\t\t\t\t\t\t// into current\n\t\t\t\t\t\tif (tiles[currentIndex] === tiles[indexBelow])\n\t\t\t\t\t\t\tcombineTwoTiles(indexBelow, currentIndex);\n\t\t\t\t\t\t// if tile found below and\n\t\t\t\t\t\t// current are not same, and\n\t\t\t\t\t\t// tile below is not one row\n\t\t\t\t\t\t// below of current, move below\n\t\t\t\t\t\t// into one tile below current\n\t\t\t\t\t\telse if (currentIndex + 4 !== indexBelow)\n\t\t\t\t\t\t\tcombineTwoTiles(indexBelow, currentIndex + 4);\n\t\t\t\t\t\t// else do nothing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if not found do nothing\n\t\t\t}\n\t\t}\n\t\t// update the state to rerender the component\n\t\t// if the tile(s) moved\n\t\tif (didMoved) updateBoard();\n\t};\n\n\t// ========== MOVING TILES DOWN ==========\n\n\t// Find the index of a tile that isn't zero on above\n\t// of given index\n\t// index -> index of a tile -> int\n\t// return -> index of a tile if found else -1\n\tconst findNumAbove = (index) => {\n\t\t// tile that is one above the index\n\t\tlet above = index - 4;\n\t\t// condition to exit the loop\n\t\tlet exit = false;\n\t\twhile (!exit) {\n\t\t\t// if the tile above is not 0, return that\n\t\t\t// index\n\t\t\tif (tiles[above] > 0) return above;\n\t\t\t// keep going above\n\t\t\tabove -= 4;\n\t\t\t// if there is no more tiles above,\n\t\t\t// exit the loop\n\t\t\tif (above < 0) exit = true;\n\t\t}\n\t\treturn -1;\n\t};\n\n\t// Move the individual tiles down if possible\n\t// go through each col, then every rows that\n\t// contains that col , then move none 0 tiles down\n\t// if there is a space\n\tconst moveDown = () => {\n\t\t// iterate through each columns left to right\n\t\tfor (let col = 0; col < 4; col++) {\n\t\t\t// iterate through rows from top to bottom\n\t\t\t// excluding the first row\n\t\t\tfor (let row = 3; row > 0; row--) {\n\t\t\t\t// one dimensional index of the tile\n\t\t\t\tlet currentIndex = oneDIndex(row, col);\n\t\t\t\t// find a non empty tile above of current\n\t\t\t\tlet indexAbove = findNumAbove(currentIndex);\n\t\t\t\t// found\n\t\t\t\tif (indexAbove !== -1) {\n\t\t\t\t\t// check if current tile is zero\n\t\t\t\t\t// if zero, move tile found above\n\t\t\t\t\t// into current\n\t\t\t\t\tif (tiles[currentIndex] === 0) {\n\t\t\t\t\t\tcombineTwoTiles(indexAbove, currentIndex);\n\t\t\t\t\t\t// stay at current place and\n\t\t\t\t\t\t// check one more time\n\t\t\t\t\t\trow++;\n\t\t\t\t\t}\n\t\t\t\t\t// is not zero\n\t\t\t\t\telse {\n\t\t\t\t\t\t// if tile found above is same as\n\t\t\t\t\t\t// current, combine tile above\n\t\t\t\t\t\t// into current\n\t\t\t\t\t\tif (tiles[currentIndex] === tiles[indexAbove])\n\t\t\t\t\t\t\tcombineTwoTiles(indexAbove, currentIndex);\n\t\t\t\t\t\t// if tile found above and\n\t\t\t\t\t\t// current are not same, and\n\t\t\t\t\t\t// tile above is not one row\n\t\t\t\t\t\t// above of current, move above\n\t\t\t\t\t\t// into one tile above current\n\t\t\t\t\t\telse if (currentIndex - 4 !== indexAbove)\n\t\t\t\t\t\t\tcombineTwoTiles(indexAbove, currentIndex - 4);\n\t\t\t\t\t\t// else do nothing\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// if not found do nothing\n\t\t\t}\n\t\t}\n\t\t// update the state to rerender the component\n\t\t// if the tile(s) moved\n\t\tif (didMoved) updateBoard();\n\t};\n\n\t// ********** HANDLE KEY PRESS **********\n\n\t// Take action accordingly after user pressed a key\n\t// key -> key pressed by user -> string\n\tconst handleKeyPress = (key) => {\n\t\tswitch (key) {\n\t\t\t// left arrow key pressed\n\t\t\t// move the tiles to left if possible\n\t\t\tcase 'ArrowLeft':\n\t\t\t\tmoveLeft();\n\t\t\t\tbreak;\n\t\t\t// up arrow key pressed\n\t\t\t// move the tiles up if possible\n\t\t\tcase 'ArrowUp':\n\t\t\t\tmoveUp();\n\t\t\t\tbreak;\n\t\t\t// right arrow key pressed\n\t\t\t// move the tiles to right if possible\n\t\t\tcase 'ArrowRight':\n\t\t\t\tmoveRight();\n\t\t\t\tbreak;\n\t\t\t// down arrow key pressed\n\t\t\t// move the tiles down if possible\n\t\t\tcase 'ArrowDown':\n\t\t\t\tmoveDown();\n\t\t\t\tbreak;\n\t\t\t// Do nothing for the rest of the key\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\t// on key press, call the handleKeyPress function\n\t// with the key value as parameter\n\t$('body').off('keyup');\n\t$('body').on('keyup', (e) => {\n\t\t// prevent scrolling\n\t\te.preventDefault();\n\t\thandleKeyPress(e.key);\n\t});\n\n\t// ========== END OF FUNCTIONALITY ==========\n\n\treturn (\n\t\t<>\n\t\t\t<h1>2048</h1>\n\t\t\t<main>\n\t\t\t\t<section>\n\t\t\t\t\t{gameMessage && (\n\t\t\t\t\t\t<div className='message'>\n\t\t\t\t\t\t\t<h2>{gameMessage}</h2>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\t\t\t\t\t{board && (\n\t\t\t\t\t\t<div id='scores'>\n\t\t\t\t\t\t\t<h3 className='score'>best : {board.best}</h3>\n\t\t\t\t\t\t\t<h3 className='score'>score : {board.score}</h3>\n\t\t\t\t\t\t\t<button onClick={handleRestart}>\n\t\t\t\t\t\t\t\t<p>restart</p>\n\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t)}\n\t\t\t\t\t<div id='game'>\n\t\t\t\t\t\t{board && (\n\t\t\t\t\t\t\t<Grid\n\t\t\t\t\t\t\t\ttiles={board.tiles}\n\t\t\t\t\t\t\t\tlatest={board.latest}\n\t\t\t\t\t\t\t\thandleKeyPress={handleKeyPress}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</div>\n\t\t\t\t\t{board && (\n\t\t\t\t\t\t<Arrows\n\t\t\t\t\t\t\tup={moveUp}\n\t\t\t\t\t\t\tright={moveRight}\n\t\t\t\t\t\t\tdown={moveDown}\n\t\t\t\t\t\t\tleft={moveLeft}\n\t\t\t\t\t\t/>\n\t\t\t\t\t)}\n\t\t\t\t</section>\n\t\t\t\t<aside id='instruction'>\n\t\t\t\t\t<Instruction />\n\t\t\t\t</aside>\n\t\t\t</main>\n\t\t</>\n\t);\n};\n\nexport default Game;\n","import './App.css';\nimport Game from './Game';\n\nfunction App() {\n\treturn (\n\t\t<div id='App'>\n\t\t\t<Game />\n\t\t</div>\n\t);\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}